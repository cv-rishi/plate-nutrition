// ./expo-env.d.ts
/// <reference types="expo/types" />

// NOTE: This file should not be edited and should be in your git ignore
// ./context/ThemeContext.tsx
import React, {
	createContext,
	useState,
	useContext,
	ReactNode,
	useEffect,
} from "react";
import { useColorScheme as useDeviceColorScheme } from "react-native";
// Consider adding AsyncStorage for persistence later:
import AsyncStorage from "@react-native-async-storage/async-storage";

type Theme = "light" | "dark";

interface ThemeContextProps {
	theme: Theme;
	setTheme: (theme: Theme) => void;
	toggleTheme: () => void;
}

const ThemeContext = createContext<ThemeContextProps | undefined>(undefined);

interface AppThemeProviderProps {
	children: ReactNode;
}

export const AppThemeProvider = ({ children }: AppThemeProviderProps) => {
	// Default to device theme initially
	const deviceTheme = useDeviceColorScheme() ?? "light";
	const [theme, setThemeState] = useState<Theme>(deviceTheme);

	// Optional: Load saved theme from storage on mount
	useEffect(() => {
		const loadTheme = async () => {
			try {
				const savedTheme = await AsyncStorage.getItem("appTheme");
				if (savedTheme === "light" || savedTheme === "dark") {
					setThemeState(savedTheme);
				} else {
					setThemeState(deviceTheme); // Fallback to device theme
				}
			} catch (error) {
				console.error("Failed to load theme from storage", error);
				setThemeState(deviceTheme); // Fallback on error
			}
		};
		loadTheme();
	}, [deviceTheme]);

	const setTheme = (newTheme: Theme) => {
		setThemeState(newTheme);
		// Optional: Save theme to storage
		AsyncStorage.setItem("appTheme", newTheme).catch((error) => {
			console.error("Failed to save theme to storage", error);
		});
	};

	const toggleTheme = () => {
		setTheme(theme === "light" ? "dark" : "light");
	};

	return (
		<ThemeContext.Provider value={{ theme, setTheme, toggleTheme }}>
			{children}
		</ThemeContext.Provider>
	);
};

export const useAppTheme = (): ThemeContextProps => {
	const context = useContext(ThemeContext);
	if (!context) {
		throw new Error("useAppTheme must be used within an AppThemeProvider");
	}
	return context;
};

// ./constants/Colors.ts
// constants/Colors.ts

// Ayu Dark (Dark Theme) Base Colors
const darkBackground = "#0b0e14"; // --bg-color
const darkForeground = "#ECEDEE"; // Default dark text for better contrast than #565b66
const darkPrimary = "#e6b450"; // --primary-color
const darkSecondary = "#39bae6"; // --secondary-color
const darkLink = "#ffb454"; // --link-color
const darkHeaderBg = "#131721"; // --header-bg
const darkIcon = "#9BA1A6"; // Default dark icon, adjust if needed

// Oldbook (Light Theme) Base Colors
const lightBackground = "#e9e2c9"; // --bg-color
const lightForeground = "#585148"; // --fg-color
const lightPrimary = "#7a1405"; // --primary-color
const lightSecondary = "#158f9c"; // --secondary-color
const lightLink = "#ffb454"; // --link-color (kept as specified)
const lightHeaderBg = "#dac9aa"; // --header-bg
const lightIcon = "#585148"; // --fg-color (adjust if needed)

export const Colors = {
	light: {
		text: lightForeground,
		background: lightBackground,
		tint: lightPrimary,
		icon: lightIcon,
		tabIconDefault: lightIcon,
		tabIconSelected: lightPrimary,

		primary: lightPrimary,
		secondary: lightSecondary,
		link: lightLink,
		headerBackground: lightHeaderBg,
	},
	dark: {
		text: darkForeground,
		background: darkBackground,
		tint: darkPrimary,
		icon: darkIcon,
		tabIconDefault: darkIcon,
		tabIconSelected: darkPrimary,

		primary: darkPrimary,
		secondary: darkSecondary,
		link: darkLink,
		headerBackground: darkHeaderBg,
	},
};

// ./app/index.tsx
import React, { useState } from "react";
import { View, TextInput, Button, StyleSheet, Alert } from "react-native";
import { useRouter } from "expo-router";
import { ThemedText } from "@/components/ThemedText";
import { ThemedView } from "@/components/ThemedView";
import { useThemeColor } from "@/hooks/useThemeColor";

export default function LoginScreen() {
	const [username, setUsername] = useState("");
	const [password, setPassword] = useState("");
	const router = useRouter();

	// Get theme colors
	const textColor = useThemeColor({}, "text");
	const backgroundColor = useThemeColor({}, "background");
	const borderColor = useThemeColor({}, "icon");
	const placeholderColor = useThemeColor({}, "icon");

	const handleLogin = () => {
		// Basic client-side check (replace with real auth later)
		if (username === "admin" && password === "password") {
			// Use a placeholder password
			router.replace("/adminDashboard");
		} else if (username === "user" && password === "password") {
			router.replace("/userDashboard");
		} else if (username === "mess Staff" && password === "password") {
			router.replace("/staffDashboard");
		} else if (username === "nutrition" && password === "password") {
			router.replace("/nutritionDashboard");
		} else {
			Alert.alert("Login Failed", "Invalid username or password");
		}
	};

	return (
		<ThemedView style={styles.container}>
			<ThemedText type="title">Login</ThemedText>
			<TextInput
				style={[
					styles.input,
					{
						color: textColor,
						backgroundColor: backgroundColor,
						borderColor: borderColor,
					},
				]}
				placeholder="Username"
				value={username}
				onChangeText={setUsername}
				placeholderTextColor={placeholderColor}
			/>
			<TextInput
				style={[
					styles.input,
					{
						color: textColor,
						backgroundColor: backgroundColor,
						borderColor: borderColor,
					},
				]}
				placeholder="Password"
				value={password}
				onChangeText={setPassword}
				secureTextEntry
				placeholderTextColor={placeholderColor}
			/>
			<Button
				title="Login"
				onPress={handleLogin}
				color={useThemeColor({}, "primary")}
			/>
		</ThemedView>
	);
}

const styles = StyleSheet.create({
	container: {
		flex: 1,
		alignItems: "center",
		justifyContent: "center",
		padding: 20,
	},
	input: {
		width: "100%",
		marginVertical: 10,
		padding: 15,
		borderWidth: 1,
		borderRadius: 5,
	},
});

// ./app/staffDashboard.tsx
import React from "react";
import { View, StyleSheet, Button } from "react-native";
import { ThemedText } from "@/components/ThemedText";
import { ThemedView } from "@/components/ThemedView";
import { useRouter } from "expo-router";

const ImageTakerScreen = () => {
	const router = useRouter();

	return (
		<ThemedView style={styles.container}>
			<ThemedText type="title">Image Taker</ThemedText>
			<ThemedText style={styles.description}>
				Welcome to the image taker interface
			</ThemedText>
			<Button title="Logout" onPress={() => router.push("/login")} />
		</ThemedView>
	);
};

const styles = StyleSheet.create({
	container: {
		flex: 1,
		justifyContent: "center",
		alignItems: "center",
		padding: 16,
	},
	description: {
		marginVertical: 20,
		textAlign: "center",
	},
});

export default ImageTakerScreen;

// ./app/_layout.tsx
import {
	DarkTheme,
	DefaultTheme,
	ThemeProvider as NavigationThemeProvider,
} from "@react-navigation/native";
import { useFonts } from "expo-font";
import { Stack } from "expo-router";
import * as SplashScreen from "expo-splash-screen";
import { useEffect } from "react";
import "react-native-reanimated";

import { useColorScheme } from "@/hooks/useColorScheme";
import { AppThemeProvider, useAppTheme } from "@/context/ThemeContext";
import { ThemeToggleButton } from "@/components/ThemeToggleButton";
import { Colors } from "@/constants/Colors";

// Prevent splash screen auto-hide
SplashScreen.preventAutoHideAsync();

// Inner component that uses the theme context
function RootNavigation() {
	const { theme } = useAppTheme();
	const headerBackgroundColor =
		theme === "light"
			? Colors.light.headerBackground
			: Colors.dark.headerBackground;
	const headerTintColor =
		theme === "light" ? Colors.light.text : Colors.dark.text;

	return (
		<NavigationThemeProvider
			value={theme === "dark" ? DarkTheme : DefaultTheme}
		>
			<Stack
				screenOptions={{
					// Apply header options globally
					headerStyle: {
						backgroundColor: headerBackgroundColor,
					},
					headerTintColor: headerTintColor,
					headerRight: () => <ThemeToggleButton />,
				}}
			>
				{/* Make the login screen show the header */}
				<Stack.Screen name="index" options={{ title: "Login" }} />

				{/* Other screens will inherit screenOptions */}
				<Stack.Screen name="admin" options={{ title: "Admin Dashboard" }} />
				<Stack.Screen name="user" options={{ title: "User Screen" }} />
				<Stack.Screen name="imagetaker" options={{ title: "Image Taker" }} />

				{/* +not-found screen */}
				<Stack.Screen name="+not-found" />
			</Stack>
		</NavigationThemeProvider>
	);
}

export default function RootLayout() {
	// Font loading logic remains the same
	const [loaded, error] = useFonts({
		SpaceMono: require("../assets/fonts/SpaceMono-Regular.ttf"),
	});

	useEffect(() => {
		if (error) throw error;
	}, [error]);

	useEffect(() => {
		if (loaded) {
			SplashScreen.hideAsync();
		}
	}, [loaded]);

	if (!loaded) {
		return null;
	}

	// Wrap the entire navigation structure with your theme provider
	return (
		<AppThemeProvider>
			<RootNavigation />
		</AppThemeProvider>
	);
}

// ./app/+not-found.tsx
import { Link, Stack } from "expo-router";
import { StyleSheet } from "react-native";

import { ThemedText } from "@/components/ThemedText";
import { ThemedView } from "@/components/ThemedView";

export default function NotFoundScreen() {
	return (
		<>
			<Stack.Screen options={{ title: "Oops!" }} />
			<ThemedView style={styles.container}>
				<ThemedText type="title">This screen doesn't exist.</ThemedText>
				<Link href="/" style={styles.link}>
					<ThemedText type="link">Go to home screen!</ThemedText>
				</Link>
			</ThemedView>
		</>
	);
}

const styles = StyleSheet.create({
	container: {
		flex: 1,
		alignItems: "center",
		justifyContent: "center",
		padding: 20,
	},
	link: {
		marginTop: 15,
		paddingVertical: 15,
	},
});

// ./app/nutritionDashboard.tsx

// ./app/adminDashboard.tsx
import React, { useState, useEffect } from "react";
import {
	StyleSheet,
	View,
	FlatList,
	Alert,
	TouchableOpacity,
	Modal,
	TextInput,
	ScrollView, // Use ScrollView for Modal content if it gets long
	Platform,
	KeyboardAvoidingView, // Handle keyboard overlap
} from "react-native";
import { Stack, useRouter } from "expo-router";
import { ThemedView } from "@/components/ThemedView";
import { ThemedText } from "@/components/ThemedText";
import { useThemeColor } from "@/hooks/useThemeColor";
import { MaterialIcons } from "@expo/vector-icons";

// Define the structure for a food item
interface FoodItem {
	id: string;
	name: string;
	description?: string; // Optional description
	// Add other relevant fields later e.g., imageUrl, calories etc.
}

// Generate some fake initial data
const generateInitialData = (count: number): FoodItem[] => {
	const items: FoodItem[] = [];
	const sampleNames = [
		"Dal Makhani",
		"Paneer Butter Masala",
		"Chicken Curry",
		"Vegetable Biryani",
		"Roti",
		"Rice",
		"Gulab Jamun",
		"Salad",
		"Samosa",
		"Idli",
		"Dosa",
		"Upma",
		"Chole Bhature",
		"Aloo Gobi",
		"Mixed Veg",
	];
	for (let i = 0; i < count; i++) {
		const name =
			sampleNames[i % sampleNames.length] +
			(count > sampleNames.length
				? ` ${Math.floor(i / sampleNames.length) + 1}`
				: "");
		items.push({
			id: `item-${Date.now()}-${i}`, // Simple unique ID
			name: name,
			description: `Description for ${name}`,
		});
	}
	return items;
};

export default function AdminScreen() {
	const router = useRouter();
	const [foodItems, setFoodItems] = useState<FoodItem[]>([]);
	const [modalVisible, setModalVisible] = useState(false);
	const [currentItem, setCurrentItem] = useState<FoodItem | null>(null); // For editing
	const [itemName, setItemName] = useState("");
	const [itemDescription, setItemDescription] = useState("");

	const cardBackground = useThemeColor({}, "headerBackground");
	const textColor = useThemeColor({}, "text");
	const iconColor = useThemeColor({}, "icon");
	const primaryColor = useThemeColor({}, "primary");
	const buttonTextColor = useThemeColor({}, "background");
	const borderColor = useThemeColor({}, "border"); // For input borders

	// Load initial data on mount
	useEffect(() => {
		setFoodItems(generateInitialData(12)); // Generate 10-15 items as requested for fake data
	}, []);

	// --- CRUD Handlers ---

	const handleAddNew = () => {
		setCurrentItem(null); // Ensure we are adding, not editing
		setItemName("");
		setItemDescription("");
		setModalVisible(true);
	};

	const handleEdit = (item: FoodItem) => {
		setCurrentItem(item);
		setItemName(item.name);
		setItemDescription(item.description || "");
		setModalVisible(true);
	};

	const handleDelete = (id: string) => {
		Alert.alert(
			"Confirm Delete",
			"Are you sure you want to delete this item?",
			[
				{ text: "Cancel", style: "cancel" },
				{
					text: "Delete",
					style: "destructive",
					onPress: () => {
						setFoodItems((prevItems) =>
							prevItems.filter((item) => item.id !== id),
						);
					},
				},
			],
		);
	};

	const handleSave = () => {
		if (!itemName.trim()) {
			Alert.alert("Error", "Item name cannot be empty.");
			return;
		}

		if (currentItem) {
			// Editing existing item
			setFoodItems((prevItems) =>
				prevItems.map((item) =>
					item.id === currentItem.id
						? {
								...item,
								name: itemName.trim(),
								description: itemDescription.trim(),
							}
						: item,
				),
			);
		} else {
			// Adding new item
			const newItem: FoodItem = {
				id: `item-${Date.now()}`, // Simple unique ID
				name: itemName.trim(),
				description: itemDescription.trim(),
			};
			setFoodItems((prevItems) => [newItem, ...prevItems]); // Add to the top
		}

		setModalVisible(false);
		// Clear form state
		setCurrentItem(null);
		setItemName("");
		setItemDescription("");
	};

	// Function to handle logout (similar to UserScreen)
	const handleLogout = () => {
		router.replace("/"); // Navigate back to login
	};

	// --- Render Item ---
	const renderItem = ({ item }: { item: FoodItem }) => (
		<View style={[styles.itemContainer, { backgroundColor: cardBackground }]}>
			<View style={styles.itemTextContainer}>
				<ThemedText style={styles.itemName}>{item.name}</ThemedText>
				{item.description && (
					<ThemedText style={styles.itemDescription} numberOfLines={2}>
						{item.description}
					</ThemedText>
				)}
			</View>
			<View style={styles.itemActions}>
				<TouchableOpacity
					onPress={() => handleEdit(item)}
					style={styles.actionButton}
				>
					<MaterialIcons name="edit" size={24} color={iconColor} />
				</TouchableOpacity>
				<TouchableOpacity
					onPress={() => handleDelete(item.id)}
					style={styles.actionButton}
				>
					<MaterialIcons name="delete" size={24} color={"red"} />{" "}
					{/* Use red for delete */}
				</TouchableOpacity>
			</View>
		</View>
	);

	return (
		<ThemedView style={styles.container}>
			<Stack.Screen
				options={{
					title: "Admin Dashboard",
					headerRight: () => (
						<TouchableOpacity
							onPress={handleLogout}
							style={styles.headerButton}
						>
							<MaterialIcons name="logout" size={24} color={iconColor} />
						</TouchableOpacity>
					),
				}}
			/>

			<FlatList
				data={foodItems}
				renderItem={renderItem}
				keyExtractor={(item) => item.id}
				style={styles.list}
				ListHeaderComponent={
					// Button to add new item at the top
					<TouchableOpacity
						style={[styles.addButton, { backgroundColor: primaryColor }]}
						onPress={handleAddNew}
					>
						<MaterialIcons name="add" size={24} color={buttonTextColor} />
						<ThemedText
							style={[styles.addButtonText, { color: buttonTextColor }]}
						>
							Add New Food Item
						</ThemedText>
					</TouchableOpacity>
				}
				ListEmptyComponent={
					<ThemedText style={styles.emptyListText}>
						No food items found. Add some!
					</ThemedText>
				}
				contentContainerStyle={styles.listContentContainer}
			/>

			{/* Add/Edit Modal */}
			<Modal
				animationType="slide"
				transparent={true}
				visible={modalVisible}
				onRequestClose={() => {
					setModalVisible(!modalVisible);
					// Optionally reset state if modal is closed via back button etc.
					setCurrentItem(null);
					setItemName("");
					setItemDescription("");
				}}
			>
				{/* Use KeyboardAvoidingView for better input handling */}
				<KeyboardAvoidingView
					behavior={Platform.OS === "ios" ? "padding" : "height"}
					style={styles.modalOverlay}
				>
					<View style={[styles.modalView, { backgroundColor: cardBackground }]}>
						<ScrollView>
							<ThemedText style={styles.modalTitle}>
								{currentItem ? "Edit Food Item" : "Add New Food Item"}
							</ThemedText>

							<ThemedText style={styles.inputLabel}>Name *</ThemedText>
							<TextInput
								style={[
									styles.input,
									{ color: textColor, borderColor: borderColor },
								]}
								placeholder="Enter item name"
								placeholderTextColor={iconColor} // Use iconColor for placeholder contrast
								value={itemName}
								onChangeText={setItemName}
							/>

							<ThemedText style={styles.inputLabel}>Description</ThemedText>
							<TextInput
								style={[
									styles.input,
									styles.textArea,
									{ color: textColor, borderColor: borderColor },
								]}
								placeholder="Enter item description (optional)"
								placeholderTextColor={iconColor}
								value={itemDescription}
								onChangeText={setItemDescription}
								multiline={true}
								numberOfLines={3}
							/>

							<View style={styles.modalActions}>
								<TouchableOpacity
									style={[styles.modalButton, styles.cancelButton]}
									onPress={() => setModalVisible(false)}
								>
									<ThemedText style={styles.modalButtonText}>Cancel</ThemedText>
								</TouchableOpacity>
								<TouchableOpacity
									style={[
										styles.modalButton,
										styles.saveButton,
										{ backgroundColor: primaryColor },
									]}
									onPress={handleSave}
								>
									<ThemedText
										style={[styles.modalButtonText, { color: buttonTextColor }]}
									>
										Save
									</ThemedText>
								</TouchableOpacity>
							</View>
						</ScrollView>
					</View>
				</KeyboardAvoidingView>
			</Modal>
		</ThemedView>
	);
}

// Styles
const styles = StyleSheet.create({
	container: {
		flex: 1,
	},
	headerButton: {
		marginRight: 15,
		padding: 5,
	},
	list: {
		flex: 1,
	},
	listContentContainer: {
		padding: 16,
	},
	addButton: {
		flexDirection: "row",
		alignItems: "center",
		justifyContent: "center",
		paddingVertical: 12,
		borderRadius: 8,
		marginBottom: 16, // Space below add button
	},
	addButtonText: {
		marginLeft: 8,
		fontSize: 16,
		fontWeight: "bold",
	},
	emptyListText: {
		textAlign: "center",
		marginTop: 50,
		fontSize: 16,
		color: "#888", // Use a subtle color
	},
	itemContainer: {
		flexDirection: "row",
		justifyContent: "space-between",
		alignItems: "center",
		padding: 15,
		marginBottom: 10,
		borderRadius: 8,
		shadowColor: "#000",
		shadowOffset: { width: 0, height: 1 },
		shadowOpacity: 0.1,
		shadowRadius: 2,
		elevation: 2,
	},
	itemTextContainer: {
		flex: 1, // Allow text to take available space
		marginRight: 10, // Space between text and actions
	},
	itemName: {
		fontSize: 16,
		fontWeight: "bold",
	},
	itemDescription: {
		fontSize: 13,
		opacity: 0.8,
		marginTop: 4,
	},
	itemActions: {
		flexDirection: "row",
	},
	actionButton: {
		marginLeft: 15, // Space between edit/delete buttons
		padding: 5, // Increase touch area
	},
	// Modal Styles
	modalOverlay: {
		flex: 1,
		justifyContent: "center",
		alignItems: "center",
		backgroundColor: "rgba(0, 0, 0, 0.5)", // Semi-transparent background
	},
	modalView: {
		margin: 20,
		borderRadius: 12,
		padding: 25, // Increased padding
		width: "90%", // Modal width
		maxHeight: "80%", // Prevent modal from being too tall
		shadowColor: "#000",
		shadowOffset: { width: 0, height: 2 },
		shadowOpacity: 0.25,
		shadowRadius: 4,
		elevation: 5,
	},
	modalTitle: {
		marginBottom: 20, // Increased spacing
		textAlign: "center",
		fontSize: 18,
		fontWeight: "bold",
	},
	inputLabel: {
		fontSize: 14,
		marginBottom: 5,
		marginLeft: 2, // Align with input border
		opacity: 0.9,
	},
	input: {
		height: 45, // Increased height
		borderWidth: 1,
		borderRadius: 8, // More rounded corners
		paddingHorizontal: 12, // Increased padding
		marginBottom: 15, // Increased spacing
		fontSize: 15,
	},
	textArea: {
		height: 80, // Height for description
		textAlignVertical: "top", // Align text to top for multiline
		paddingTop: 10, // Padding top for multiline
	},
	modalActions: {
		flexDirection: "row",
		justifyContent: "flex-end", // Align buttons to the right
		marginTop: 20,
	},
	modalButton: {
		borderRadius: 8,
		paddingVertical: 10,
		paddingHorizontal: 20,
		marginLeft: 10,
		minWidth: 80, // Ensure minimum button width
		alignItems: "center", // Center text
	},
	cancelButton: {
		backgroundColor: "#ccc", // A standard cancel color
	},
	saveButton: {
		// backgroundColor set by primaryColor
	},
	modalButtonText: {
		fontWeight: "bold",
		fontSize: 15,
	},
});

// ./app/home.tsx
import React from "react";
import { View, Text, StyleSheet } from "react-native";

const HomeScreen = () => {
	return (
		<View style={styles.container}>
			<Text>Welcome to the Home Screen!</Text>
			{/* Display user-specific content here */}
		</View>
	);
};

const styles = StyleSheet.create({
	container: {
		flex: 1,
		justifyContent: "center",
		alignItems: "center",
	},
});

export default HomeScreen;

// ./app/userDashboard.tsx
import React, { useState } from "react";
import {
	StyleSheet,
	View,
	Image,
	TouchableOpacity,
	ScrollView,
	Button,
	Platform,
	Alert, // Added Alert
} from "react-native";
import { Stack, useRouter } from "expo-router";
import { ThemedView } from "@/components/ThemedView";
import { ThemedText } from "@/components/ThemedText";
import { CameraComponent } from "@/components/CameraComponent";
import { useThemeColor } from "@/hooks/useThemeColor";
import { MaterialIcons } from "@expo/vector-icons";
import { StarRating } from "@/components/StarRating";

export default function UserScreen() {
	const [photoUri, setPhotoUri] = useState<string | null>(null);
	const [showCamera, setShowCamera] = useState(false);
	const [nutritionalInfo, setNutritionalInfo] = useState<string | null>(null);
	// NEW: State for model's confidence score
	const [modelConfidence, setModelConfidence] = useState<number | null>(null);
	// REPURPOSED: State for the USER'S rating input
	const [userRating, setUserRating] = useState<number | null>(null);
	// State to track if results are being loaded
	const [isLoading, setIsLoading] = useState(false);

	const router = useRouter();

	const buttonColor = useThemeColor({}, "primary");
	const buttonTextColor = useThemeColor({}, "background");
	const cardBackground = useThemeColor({}, "headerBackground");
	const textColor = useThemeColor({}, "text");
	const iconColor = useThemeColor({}, "icon");

	const handlePictureTaken = (uri: string) => {
		setPhotoUri(uri);
		setShowCamera(false);
		setIsLoading(true); // Start loading indicator
		setNutritionalInfo(null); // Clear previous results
		setModelConfidence(null);
		setUserRating(null); // Reset user rating for new picture

		console.log("Photo URI:", uri);
		// --- Backend Interaction Placeholder ---
		// Simulate backend processing delay
		setTimeout(() => {
			// Assume backend returns nutritional info and model confidence
			setNutritionalInfo("Calories: 410, Protein: 18g, Carbs: 55g, Fat: 12g");
			setModelConfidence(0.85); // Example confidence score (e.g., 85%)
			setIsLoading(false); // Stop loading indicator
		}, 2000); // Simulate 2 second network delay
		// --- End Backend Interaction Placeholder ---
	};

	// Handler for the user setting their rating
	const handleSetUserRating = (rating: number) => {
		setUserRating(rating);
		// Optional: Send the user rating to the backend here
		console.log("User rated:", rating);
		Alert.alert(
			"Rating Submitted",
			`You rated ${rating} stars. Thank you for your feedback!`,
		); // Give feedback
	};

	const handleOpenCamera = () => {
		// Clear all previous results and states when opening camera
		setPhotoUri(null);
		setNutritionalInfo(null);
		setModelConfidence(null);
		setUserRating(null);
		setIsLoading(false);
		setShowCamera(true);
	};

	const handleCloseCamera = () => {
		setShowCamera(false);
	};

	const handleLogout = () => {
		router.replace("/");
	};

	if (showCamera) {
		return (
			<CameraComponent
				onPictureTaken={handlePictureTaken}
				onClose={handleCloseCamera}
			/>
		);
	}

	return (
		<ThemedView style={styles.container}>
			<Stack.Screen
				options={{
					title: "User Dashboard",
					headerRight: () => (
						<TouchableOpacity
							onPress={handleLogout}
							style={styles.headerButton}
						>
							<MaterialIcons name="logout" size={24} color={iconColor} />
						</TouchableOpacity>
					),
				}}
			/>

			<ScrollView
				style={styles.content}
				contentContainerStyle={styles.contentContainer}
				keyboardShouldPersistTaps="handled" // Allow taps outside inputs to dismiss keyboard if needed later
			>
				{/* Card for Camera Action */}
				<View style={[styles.card, { backgroundColor: cardBackground }]}>
					<ThemedText type="subtitle" style={styles.cardTitle}>
						Analyze Meal
					</ThemedText>
					{/* ... (Image display or placeholder remains the same) ... */}
					{
						photoUri && !isLoading ? ( // Show image if not loading
							<View style={styles.photoContainer}>
								<ThemedText style={styles.infoLabel}>
									Captured Image:
								</ThemedText>
								<Image source={{ uri: photoUri }} style={styles.photo} />
							</View>
						) : !photoUri && !isLoading ? ( // Show placeholder if no photo and not loading
							<View style={styles.placeholder}>
								<MaterialIcons name="camera-alt" size={50} color={iconColor} />
								<ThemedText style={styles.placeholderText}>
									Press the button below to take a picture of your meal.
								</ThemedText>
							</View>
						) : null /* Or show a specific placeholder during loading if desired */
					}

					<TouchableOpacity
						style={[styles.button, { backgroundColor: buttonColor }]}
						onPress={handleOpenCamera}
						disabled={isLoading} // Disable button while loading
					>
						<MaterialIcons
							name="camera"
							size={20}
							color={buttonTextColor}
							style={{ marginRight: 8 }}
						/>
						<ThemedText style={[styles.buttonText, { color: buttonTextColor }]}>
							{photoUri ? "Analyze Another Meal" : "Take Picture"}
						</ThemedText>
					</TouchableOpacity>
				</View>

				{/* Card for Results (shown after photo is taken OR during loading) */}
				{(photoUri || isLoading) && (
					<View style={[styles.card, { backgroundColor: cardBackground }]}>
						<ThemedText type="subtitle" style={styles.cardTitle}>
							Analysis Results
						</ThemedText>

						{isLoading ? (
							<ThemedText style={styles.infoText}>
								Analyzing image...
							</ThemedText>
						) : nutritionalInfo ? (
							<>
								{/* Display Model Confidence */}
								{modelConfidence !== null && (
									<>
										<ThemedText style={styles.infoLabel}>
											Model Confidence:
										</ThemedText>
										<ThemedText style={styles.infoText}>
											{(modelConfidence * 100).toFixed(0)}%{" "}
											{/* Display as percentage */}
										</ThemedText>
									</>
								)}

								{/* Display Nutritional Values */}
								<ThemedText style={[styles.infoLabel, { marginTop: 15 }]}>
									Nutritional Values:
								</ThemedText>
								<ThemedText style={styles.infoText}>
									{nutritionalInfo}
								</ThemedText>

								{/* User Rating Section */}
								<ThemedText style={[styles.infoLabel, { marginTop: 15 }]}>
									Rate this Analysis:
								</ThemedText>
								<StarRating
									rating={userRating} // Pass the user's current rating state
									onRate={handleSetUserRating} // Pass the handler function
									size={32} // Make stars larger for interaction
								/>
							</>
						) : (
							// Handle case where loading finished but no info (e.g., error)
							<ThemedText style={styles.infoText}>
								Could not analyze image.
							</ThemedText>
						)}
					</View>
				)}
			</ScrollView>
		</ThemedView>
	);
}

// Styles (add or adjust as needed)
const styles = StyleSheet.create({
	// ... (Keep existing styles: container, headerButton, content, contentContainer, card, cardTitle) ...
	container: {
		flex: 1,
	},
	headerButton: {
		marginRight: 15,
		padding: 5,
	},
	content: {
		flex: 1,
	},
	contentContainer: {
		padding: 16,
		paddingBottom: 32, // Ensure space at the bottom
	},
	card: {
		borderRadius: 12,
		padding: 16,
		marginBottom: 20,
		shadowColor: "#000",
		shadowOffset: { width: 0, height: 1 },
		shadowOpacity: 0.1,
		shadowRadius: 3,
		elevation: 3,
	},
	cardTitle: {
		marginBottom: 15,
		textAlign: "center",
	},
	photoContainer: {
		alignItems: "center",
		marginVertical: 16,
		width: "100%",
	},
	photo: {
		width: "90%",
		aspectRatio: 1,
		borderRadius: 8,
		marginTop: 8,
		resizeMode: "cover",
	},
	placeholder: {
		height: 180,
		borderRadius: 8,
		justifyContent: "center",
		alignItems: "center",
		alignSelf: "center",
		marginVertical: 20,
		width: "90%",
		padding: 15,
	},
	placeholderText: {
		marginTop: 10,
		fontStyle: "italic",
		textAlign: "center",
		opacity: 0.8,
	},
	button: {
		flexDirection: "row",
		paddingVertical: 12,
		paddingHorizontal: 20,
		borderRadius: 8,
		alignItems: "center",
		justifyContent: "center",
		marginTop: 16,
		minWidth: 180,
		alignSelf: "center",
	},
	buttonText: {
		fontSize: 16,
		fontWeight: "bold",
	},
	infoLabel: {
		fontWeight: "bold",
		marginTop: 10,
		fontSize: 16,
	},
	infoText: {
		fontSize: 15,
		marginTop: 5,
		lineHeight: 22,
	},
});

// ./hooks/useThemeColor.ts
/**
 * Learn more about light and dark modes:
 * https://docs.expo.dev/guides/color-schemes/
 */

import { Colors } from '@/constants/Colors';
import { useColorScheme } from '@/hooks/useColorScheme';

export function useThemeColor(
  props: { light?: string; dark?: string },
  colorName: keyof typeof Colors.light & keyof typeof Colors.dark
) {
  const theme = useColorScheme() ?? 'light';
  const colorFromProps = props[theme];

  if (colorFromProps) {
    return colorFromProps;
  } else {
    return Colors[theme][colorName];
  }
}

// ./hooks/useColorScheme.web.ts
import { useEffect, useState } from 'react';
import { useColorScheme as useRNColorScheme } from 'react-native';

/**
 * To support static rendering, this value needs to be re-calculated on the client side for web
 */
export function useColorScheme() {
  const [hasHydrated, setHasHydrated] = useState(false);

  useEffect(() => {
    setHasHydrated(true);
  }, []);

  const colorScheme = useRNColorScheme();

  if (hasHydrated) {
    return colorScheme;
  }

  return 'light';
}

// ./hooks/useColorScheme.ts
import { useAppTheme } from "@/context/ThemeContext"; // Import the hook

/**
 * Hook that provides the current color scheme preference (light or dark).
 * Prioritizes the user's choice from ThemeContext.
 */
export function useColorScheme(): "light" | "dark" {
	const { theme } = useAppTheme(); // Get the theme from context
	return theme;
}

// You might not need the .web.ts variant anymore, or it should also use the context.

// ./.expo/types/router.d.ts
/* eslint-disable */
import * as Router from 'expo-router';

export * from 'expo-router';

declare module 'expo-router' {
  export namespace ExpoRouter {
    export interface __routes<T extends string | object = string> {
      hrefInputParams: { pathname: Router.RelativePathString, params?: Router.UnknownInputParams } | { pathname: Router.ExternalPathString, params?: Router.UnknownInputParams } | { pathname: `/adminDashboard`; params?: Router.UnknownInputParams; } | { pathname: `/home`; params?: Router.UnknownInputParams; } | { pathname: `/`; params?: Router.UnknownInputParams; } | { pathname: `/nutritionDashboard`; params?: Router.UnknownInputParams; } | { pathname: `/staffDashboard`; params?: Router.UnknownInputParams; } | { pathname: `/userDashboard`; params?: Router.UnknownInputParams; } | { pathname: `/_sitemap`; params?: Router.UnknownInputParams; } | { pathname: `/+not-found`, params: Router.UnknownInputParams & {  } };
      hrefOutputParams: { pathname: Router.RelativePathString, params?: Router.UnknownOutputParams } | { pathname: Router.ExternalPathString, params?: Router.UnknownOutputParams } | { pathname: `/adminDashboard`; params?: Router.UnknownOutputParams; } | { pathname: `/home`; params?: Router.UnknownOutputParams; } | { pathname: `/`; params?: Router.UnknownOutputParams; } | { pathname: `/nutritionDashboard`; params?: Router.UnknownOutputParams; } | { pathname: `/staffDashboard`; params?: Router.UnknownOutputParams; } | { pathname: `/userDashboard`; params?: Router.UnknownOutputParams; } | { pathname: `/_sitemap`; params?: Router.UnknownOutputParams; } | { pathname: `/+not-found`, params: Router.UnknownOutputParams & {  } };
      href: Router.RelativePathString | Router.ExternalPathString | `/adminDashboard${`?${string}` | `#${string}` | ''}` | `/home${`?${string}` | `#${string}` | ''}` | `/${`?${string}` | `#${string}` | ''}` | `/nutritionDashboard${`?${string}` | `#${string}` | ''}` | `/staffDashboard${`?${string}` | `#${string}` | ''}` | `/userDashboard${`?${string}` | `#${string}` | ''}` | `/_sitemap${`?${string}` | `#${string}` | ''}` | { pathname: Router.RelativePathString, params?: Router.UnknownInputParams } | { pathname: Router.ExternalPathString, params?: Router.UnknownInputParams } | { pathname: `/adminDashboard`; params?: Router.UnknownInputParams; } | { pathname: `/home`; params?: Router.UnknownInputParams; } | { pathname: `/`; params?: Router.UnknownInputParams; } | { pathname: `/nutritionDashboard`; params?: Router.UnknownInputParams; } | { pathname: `/staffDashboard`; params?: Router.UnknownInputParams; } | { pathname: `/userDashboard`; params?: Router.UnknownInputParams; } | { pathname: `/_sitemap`; params?: Router.UnknownInputParams; } | `/+not-found` | { pathname: `/+not-found`, params: Router.UnknownInputParams & {  } };
    }
  }
}

// ./components/ThemeToggleButton.tsx
import React from "react";
import { Pressable, StyleSheet } from "react-native";
import { useAppTheme } from "@/context/ThemeContext";
import { ThemedText } from "./ThemedText"; // Use ThemedText for the icon
import { useThemeColor } from "@/hooks/useThemeColor";

export function ThemeToggleButton() {
  const { theme, toggleTheme } = useAppTheme();
  const iconColor = useThemeColor({}, "icon"); // Get icon color from theme

  return (
    <Pressable onPress={toggleTheme} style={styles.button}>
      {/* Simple Text Icon - Replace with actual Icon component if available */}
      <ThemedText style={{ color: iconColor, fontSize: 20 }}>
        {theme === "light" ? "‚òÄÔ∏è" : "üåô"}
      </ThemedText>
    </Pressable>
  );
}

const styles = StyleSheet.create({
  button: {
    marginRight: 15, // Add some spacing from the edge
    padding: 5,
  },
});

// ./components/CameraComponent.tsx
import React, { useState, useRef, useEffect } from "react";
import {
	View,
	StyleSheet,
	TouchableOpacity,
	Text,
	Alert,
	Platform,
	Button,
} from "react-native";
import { CameraView, CameraType, useCameraPermissions } from "expo-camera";
import { MaterialIcons } from "@expo/vector-icons";
import { useThemeColor } from "@/hooks/useThemeColor";
import AsyncStorage from "@react-native-async-storage/async-storage";

type CameraComponentProps = {
	onPictureTaken: (uri: string) => void;
	onClose: () => void;
};

export function CameraComponent({
	onPictureTaken,
	onClose,
}: CameraComponentProps) {
	const [permission, requestPermission] = useCameraPermissions();
	const [facing, setFacing] = useState<CameraType>("back");
	const cameraRef = useRef<CameraView>(null); // Ref type updated to CameraView
	const iconColor = useThemeColor({}, "icon");
	const buttonBackgroundColor = useThemeColor({}, "primary");
	const buttonTextColor = useThemeColor({}, "background");

	useEffect(() => {
		const loadCameraType = async () => {
			const savedType = await AsyncStorage.getItem("cameraType");
			if (savedType === "front") {
				setFacing("front");
			} else {
				setFacing("back"); // Default to 'back'
			}
		};
		loadCameraType();
	}, []);

	if (!permission) {
		// Permissions are still loading
		return (
			<View style={styles.centered}>
				<Text>Requesting camera permissions...</Text>
			</View>
		);
	}

	if (!permission.granted) {
		return (
			<View style={[styles.container, styles.centered]}>
				<Stack.Screen options={{ headerShown: false }} />{" "}
				{/* Optionally hide header */}
				<Text style={styles.message}>
					We need your permission to show the camera.
				</Text>
				<Button onPress={requestPermission} title="Grant Permission" />
				<Button onPress={onClose} title="Cancel" />
			</View>
		);
	}

	const toggleCameraFacing = async () => {
		const newFacing = facing === "back" ? "front" : "back";
		setFacing(newFacing);
		await AsyncStorage.setItem("cameraType", newFacing);
	};

	const takePicture = async () => {
		if (cameraRef.current) {
			try {
				const photo = await cameraRef.current.takePictureAsync({
					quality: 0.7,
					base64: false,
				});
				if (photo?.uri) {
					onPictureTaken(photo.uri);
				} else {
					console.error("Failed to take picture: No URI returned");
					Alert.alert("Error", "Could not capture image.");
				}
			} catch (error) {
				console.error("Failed to take picture:", error);
				Alert.alert("Error", "Could not take picture.");
			}
		}
	};

	return (
		// Use CameraView instead of Camera
		<View style={styles.cameraContainer}>
			<CameraView
				ref={cameraRef}
				style={styles.camera}
				facing={facing} // Use facing prop
				// FlashMode might be handled differently or via props if needed
				// ratio="16:9" // Ratio might not be needed or set differently
			>
				{/* Keep controls within the CameraView or overlay them */}
				<View style={styles.cameraControls}>
					{/* Close Button */}
					<TouchableOpacity style={styles.controlButton} onPress={onClose}>
						<MaterialIcons name="close" size={30} color={iconColor} />
					</TouchableOpacity>
					{/* Flip Camera Button */}
					<TouchableOpacity
						style={styles.controlButton}
						onPress={toggleCameraFacing}
					>
						<MaterialIcons name="flip-camera-ios" size={30} color={iconColor} />
					</TouchableOpacity>
				</View>
			</CameraView>

			{/* Capture Button outside CameraView for positioning */}
			<TouchableOpacity
				style={[
					styles.captureButton,
					{ backgroundColor: buttonBackgroundColor },
				]}
				onPress={takePicture}
			>
				<MaterialIcons name="camera" size={40} color={buttonTextColor} />
			</TouchableOpacity>
		</View>
	);
}

// Styles remain largely the same, adjust as needed
const styles = StyleSheet.create({
	container: {
		// Added for permission screen
		flex: 1,
		justifyContent: "center",
		alignItems: "center",
		padding: 20,
	},
	centered: {
		// Added for centering content
		flex: 1,
		justifyContent: "center",
		alignItems: "center",
	},
	message: {
		// Added for permission screen
		textAlign: "center",
		marginBottom: 20,
		fontSize: 16,
	},
	cameraContainer: {
		flex: 1,
		width: "100%",
		backgroundColor: "#000",
		justifyContent: "flex-end",
		alignItems: "center",
	},
	camera: {
		// Adjust camera style: Make it cover most of the screen, leave space for controls maybe?
		position: "absolute",
		top: 0,
		left: 0,
		right: 0,
		bottom: 120, // Adjust space for the capture button area
	},
	cameraControls: {
		// Position controls at the top within the CameraView bounds or overlay
		flexDirection: "row",
		justifyContent: "space-between",
		backgroundColor: "transparent",
		width: "100%", // Ensure controls span width
		paddingHorizontal: 20,
		paddingTop: Platform.OS === "ios" ? 50 : 30, // Adjust for status bar/notch
		position: "absolute", // Position controls over the camera view
		top: 0,
		left: 0,
		right: 0,
		zIndex: 1, // Ensure controls are above the camera preview layer if needed
	},
	controlButton: {
		padding: 10,
		borderRadius: 50,
		backgroundColor: "rgba(0,0,0,0.4)",
	},
	captureButton: {
		width: 70,
		height: 70,
		borderRadius: 35,
		justifyContent: "center",
		alignItems: "center",
		marginBottom: 40, // Adjusted margin
		position: "absolute", // Position capture button absolutely at the bottom center
		bottom: 10,
		alignSelf: "center",
		zIndex: 2, // Ensure capture button is easily pressable
	},
});

// ./components/StarRating.tsx
import React from "react";
import { View, StyleSheet, TouchableOpacity } from "react-native"; // Added TouchableOpacity
import { MaterialIcons } from "@expo/vector-icons";
import { useThemeColor } from "@/hooks/useThemeColor";

interface StarRatingProps {
	rating: number | null; // Current rating value (can be null if unrated)
	maxStars?: number;
	size?: number;
	onRate?: (rating: number) => void; // Optional: Callback function when user rates
	disabled?: boolean; // Optional: Disable interaction
}

export function StarRating({
	rating,
	maxStars = 5,
	size = 28, // Slightly larger default for interaction
	onRate,
	disabled = false, // Default to interactive if onRate is provided
}: StarRatingProps) {
	const starColor = useThemeColor({}, "tint");
	const emptyStarColor = useThemeColor({}, "icon");
	// Determine if the component should be interactive
	const isInteractive = !!onRate && !disabled;

	const handlePress = (index: number) => {
		if (isInteractive && onRate) {
			onRate(index + 1); // Rating is 1-based index + 1
		}
	};

	// Calculate filled stars based on the current rating prop
	const filledStars = rating ? Math.floor(rating) : 0;
	// Note: We won't show half stars for user input for simplicity,
	// but could be added if needed. Displaying previously set half stars is still possible.
	const displayRating = rating ?? 0; // Use 0 if rating is null for calculation
	const fullStars = Math.floor(displayRating);
	const halfStar = !isInteractive && displayRating % 1 >= 0.5; // Show half stars only when displaying, not interacting
	const emptyStars = maxStars - fullStars - (halfStar ? 1 : 0);

	return (
		<View style={styles.container}>
			{[...Array(maxStars)].map((_, i) => {
				const starValue = i + 1;
				let iconName: "star" | "star-border" | "star-half" = "star-border";
				let color = emptyStarColor;

				if (rating !== null) {
					// Only determine filled/half if there's a rating
					if (i < fullStars) {
						iconName = "star";
						color = starColor;
					} else if (i === fullStars && halfStar) {
						iconName = "star-half";
						color = starColor;
					}
				}

				return (
					<TouchableOpacity
						key={i}
						onPress={() => handlePress(i)}
						disabled={!isInteractive}
						style={styles.starTouchable} // Add touchable area style
					>
						<MaterialIcons
							name={iconName}
							size={size}
							color={
								isInteractive && rating !== null && starValue <= rating
									? starColor
									: color
							} // Ensure interactive selection shows filled stars
						/>
					</TouchableOpacity>
				);
			})}
		</View>
	);
}

const styles = StyleSheet.create({
	container: {
		flexDirection: "row",
		alignItems: "center",
		marginTop: 5,
	},
	starTouchable: {
		paddingHorizontal: 3, // Add some padding around stars for easier touch
	},
});

// ./components/ThemedView.tsx
import { View, type ViewProps, StyleSheet } from "react-native";
import { useThemeColor } from "@/hooks/useThemeColor";

export type ThemedViewProps = ViewProps & {
	lightColor?: string;
	darkColor?: string;
};

export function ThemedView({
	style,
	lightColor,
	darkColor,
	...otherProps
}: ThemedViewProps) {
	const backgroundColor = useThemeColor(
		{ light: lightColor, dark: darkColor },
		"background",
	);

	return <View style={[{ backgroundColor }, style]} {...otherProps} />;
}

// ./components/ThemedText.tsx
import { Text, type TextProps, StyleSheet } from 'react-native';

import { useThemeColor } from '@/hooks/useThemeColor';

export type ThemedTextProps = TextProps & {
  lightColor?: string;
  darkColor?: string;
  type?: 'default' | 'title' | 'defaultSemiBold' | 'subtitle' | 'link';
};

export function ThemedText({
  style,
  lightColor,
  darkColor,
  type = 'default',
  ...rest
}: ThemedTextProps) {
  const color = useThemeColor({ light: lightColor, dark: darkColor }, 'text');

  return (
    <Text
      style={[
        { color },
        type === 'default' ? styles.default : undefined,
        type === 'title' ? styles.title : undefined,
        type === 'defaultSemiBold' ? styles.defaultSemiBold : undefined,
        type === 'subtitle' ? styles.subtitle : undefined,
        type === 'link' ? styles.link : undefined,
        style,
      ]}
      {...rest}
    />
  );
}

const styles = StyleSheet.create({
  default: {
    fontSize: 16,
    lineHeight: 24,
  },
  defaultSemiBold: {
    fontSize: 16,
    lineHeight: 24,
    fontWeight: '600',
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    lineHeight: 32,
  },
  subtitle: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  link: {
    lineHeight: 30,
    fontSize: 16,
    color: '#0a7ea4',
  },
});

// ./components/ExternalLink.tsx
import { Link } from 'expo-router';
import { openBrowserAsync } from 'expo-web-browser';
import { type ComponentProps } from 'react';
import { Platform } from 'react-native';

type Props = Omit<ComponentProps<typeof Link>, 'href'> & { href: string };

export function ExternalLink({ href, ...rest }: Props) {
  return (
    <Link
      target="_blank"
      {...rest}
      href={href}
      onPress={async (event) => {
        if (Platform.OS !== 'web') {
          // Prevent the default behavior of linking to the default browser on native.
          event.preventDefault();
          // Open the link in an in-app browser.
          await openBrowserAsync(href);
        }
      }}
    />
  );
}

// ./components/ui/TabBarBackground.tsx
// This is a shim for web and Android where the tab bar is generally opaque.
export default undefined;

export function useBottomTabOverflow() {
  return 0;
}

// ./components/ui/TabBarBackground.ios.tsx
import { useBottomTabBarHeight } from '@react-navigation/bottom-tabs';
import { BlurView } from 'expo-blur';
import { StyleSheet } from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

export default function BlurTabBarBackground() {
  return (
    <BlurView
      // System chrome material automatically adapts to the system's theme
      // and matches the native tab bar appearance on iOS.
      tint="systemChromeMaterial"
      intensity={100}
      style={StyleSheet.absoluteFill}
    />
  );
}

export function useBottomTabOverflow() {
  const tabHeight = useBottomTabBarHeight();
  const { bottom } = useSafeAreaInsets();
  return tabHeight - bottom;
}


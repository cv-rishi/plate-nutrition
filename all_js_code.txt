// ./expo-env.d.ts
/// <reference types="expo/types" />

// NOTE: This file should not be edited and should be in your git ignore
// ./context/ThemeContext.tsx
import React, {
	createContext,
	useState,
	useContext,
	ReactNode,
	useEffect,
} from "react";
import { useColorScheme as useDeviceColorScheme } from "react-native";
// Consider adding AsyncStorage for persistence later:
import AsyncStorage from "@react-native-async-storage/async-storage";

type Theme = "light" | "dark";

interface ThemeContextProps {
	theme: Theme;
	setTheme: (theme: Theme) => void;
	toggleTheme: () => void;
}

const ThemeContext = createContext<ThemeContextProps | undefined>(undefined);

interface AppThemeProviderProps {
	children: ReactNode;
}

export const AppThemeProvider = ({ children }: AppThemeProviderProps) => {
	// Default to device theme initially
	const deviceTheme = useDeviceColorScheme() ?? "light";
	const [theme, setThemeState] = useState<Theme>(deviceTheme);

	// Optional: Load saved theme from storage on mount
	useEffect(() => {
		const loadTheme = async () => {
			try {
				const savedTheme = await AsyncStorage.getItem("appTheme");
				if (savedTheme === "light" || savedTheme === "dark") {
					setThemeState(savedTheme);
				} else {
					setThemeState(deviceTheme); // Fallback to device theme
				}
			} catch (error) {
				console.error("Failed to load theme from storage", error);
				setThemeState(deviceTheme); // Fallback on error
			}
		};
		loadTheme();
	}, [deviceTheme]);

	const setTheme = (newTheme: Theme) => {
		setThemeState(newTheme);
		// Optional: Save theme to storage
		AsyncStorage.setItem("appTheme", newTheme).catch((error) => {
			console.error("Failed to save theme to storage", error);
		});
	};

	const toggleTheme = () => {
		setTheme(theme === "light" ? "dark" : "light");
	};

	return (
		<ThemeContext.Provider value={{ theme, setTheme, toggleTheme }}>
			{children}
		</ThemeContext.Provider>
	);
};

export const useAppTheme = (): ThemeContextProps => {
	const context = useContext(ThemeContext);
	if (!context) {
		throw new Error("useAppTheme must be used within an AppThemeProvider");
	}
	return context;
};

// ./constants/Colors.ts
// constants/Colors.ts

// Ayu Dark (Dark Theme) Base Colors
const darkBackground = "#0b0e14"; // --bg-color
const darkForeground = "#ECEDEE"; // Default dark text for better contrast than #565b66
const darkPrimary = "#e6b450"; // --primary-color
const darkSecondary = "#39bae6"; // --secondary-color
const darkLink = "#ffb454"; // --link-color
const darkHeaderBg = "#131721"; // --header-bg
const darkIcon = "#9BA1A6"; // Default dark icon, adjust if needed

// Oldbook (Light Theme) Base Colors
const lightBackground = "#e9e2c9"; // --bg-color
const lightForeground = "#585148"; // --fg-color
const lightPrimary = "#7a1405"; // --primary-color
const lightSecondary = "#158f9c"; // --secondary-color
const lightLink = "#ffb454"; // --link-color (kept as specified)
const lightHeaderBg = "#dac9aa"; // --header-bg
const lightIcon = "#585148"; // --fg-color (adjust if needed)

export const Colors = {
	light: {
		text: lightForeground,
		background: lightBackground,
		tint: lightPrimary,
		icon: lightIcon,
		tabIconDefault: lightIcon,
		tabIconSelected: lightPrimary,

		primary: lightPrimary,
		secondary: lightSecondary,
		link: lightLink,
		headerBackground: lightHeaderBg,

		separator: "#ccc", // Example separator color
		inputBackground: "#f0f0f0", // Light theme input background
		inputBorder: "#ccc", // Light theme input border
		placeholderText: "#999", // Light theme placeholder text
	},
	dark: {
		text: darkForeground,
		background: darkBackground,
		tint: darkPrimary,
		icon: darkIcon,
		tabIconDefault: darkIcon,
		tabIconSelected: darkPrimary,

		primary: darkPrimary,
		secondary: darkSecondary,
		link: darkLink,
		headerBackground: darkHeaderBg,

		inputBackground: "#2c2c2e", // Dark theme input background
		inputBorder: "#444", // Dark theme input border
		placeholderText: "#777", // Dark theme placeholder text
	},
};

// ./app/signup.tsx
import React from "react";
import { StyleSheet } from "react-native";
import { ThemedView } from "@/components/ThemedView";
import { ThemedText } from "@/components/ThemedText";
import { useRouter } from "expo-router";
import { Button } from "react-native";

export default function SignUpScreen() {
	const router = useRouter();

	return (
		<ThemedView style={styles.container}>
			<ThemedText type="title">Sign Up</ThemedText>
			{/* Add your sign-up form fields here */}
			<ThemedText>Sign Up Form Will Go Here</ThemedText>
			<Button title="Back to Home" onPress={() => router.back()} />
		</ThemedView>
	);
}

const styles = StyleSheet.create({
	container: {
		flex: 1,
		alignItems: "center",
		justifyContent: "center",
		padding: 20,
	},
});

// ./app/index.tsx
import React from "react";
import { StyleSheet } from "react-native";
import { Link } from "expo-router"; // Import Link
import { ThemedView } from "@/components/ThemedView";
import { ThemedText } from "@/components/ThemedText";
import { Button } from "react-native"; // Or use a custom ThemedButton if you have one

export default function HomeScreen() {
	return (
		<ThemedView style={styles.container}>
			<ThemedText type="title">Welcome!</ThemedText>
			<ThemedText>Please log in or sign up to continue.</ThemedText>

			{/* Use Link for navigation */}
			<Link href="/login" asChild>
				<Button title="Log In" />
			</Link>

			<Link href="/signup" asChild>
				<Button title="Sign Up" />
			</Link>

			{/* Add some spacing if needed */}
			<ThemedView style={{ height: 20 }} />
		</ThemedView>
	);
}

const styles = StyleSheet.create({
	container: {
		flex: 1,
		alignItems: "center",
		justifyContent: "center",
		padding: 20,
	},
	// Add other styles as needed
});

// ./app/staffDashboard.tsx
import React, { useState, useEffect } from "react";
import {
	View,
	StyleSheet,
	Button,
	Alert,
	TouchableOpacity,
	ScrollView,
	Image,
	Text,
	Modal,
} from "react-native";
import { ThemedView } from "@/components/ThemedView";
import { ThemedText } from "@/components/ThemedText";
import { ThemedTextInput } from "@/components/ThemedTextInput";
import { CameraComponent } from "@/components/CameraComponent";
import { MaterialIcons, Ionicons } from "@expo/vector-icons";
import { useThemeColor } from "@/hooks/useThemeColor";
import { router } from "expo-router";

// --- Data Structure and Fake Data ---
interface FoodItem {
	id: string;
	name: string;
	mealCategory?: "Breakfast" | "Lunch" | "Dinner" | "Snacks";
}

// Food database (available items to choose from)
const availableFoodItems: FoodItem[] = [
	{ id: "1", name: "Apple" },
	{ id: "2", name: "Chicken Breast (100g)" },
	{ id: "3", name: "Brown Rice (cooked, 1 cup)" },
	{ id: "4", name: "Broccoli (1 cup)" },
	{ id: "5", name: "Whole Wheat Bread" },
	{ id: "6", name: "Scrambled Eggs" },
	{ id: "7", name: "Greek Yogurt" },
	{ id: "8", name: "Grilled Salmon" },
	{ id: "9", name: "Quinoa Salad" },
	{ id: "10", name: "Mixed Nuts" },
	{ id: "11", name: "Banana" },
	{ id: "12", name: "Oatmeal" },
	{ id: "13", name: "Sweet Potato" },
	{ id: "14", name: "Tofu" },
	{ id: "15", name: "Avocado" },
];

type CameraMode = "buffet" | "plate" | "container" | null;
type MealCategory = "Breakfast" | "Lunch" | "Dinner" | "Snacks";

export default function StaffDashboardScreen() {
	const [currentDate, setCurrentDate] = useState(new Date());
	const [trackedFoodItems, setTrackedFoodItems] = useState<FoodItem[]>([]);
	const [expandedMeals, setExpandedMeals] = useState<
		Record<MealCategory, boolean>
	>({
		Breakfast: true,
		Lunch: false,
		Dinner: false,
		Snacks: false,
	});

	// Food selection modal state
	const [showFoodModal, setShowFoodModal] = useState(false);
	const [selectedMeal, setSelectedMeal] = useState<MealCategory | null>(null);
	const [searchTerm, setSearchTerm] = useState("");

	// Camera & measurement states
	const [showCamera, setShowCamera] = useState(false);
	const [cameraMode, setCameraMode] = useState<CameraMode>(null);
	const [activeFoodItem, setActiveFoodItem] = useState<FoodItem | null>(null);
	const [weight, setWeight] = useState("");
	const [volume, setVolume] = useState("");
	const [density, setDensity] = useState<number | null>(null);

	// Image states
	const [imageData, setImageData] = useState<
		Record<
			string,
			{
				buffet: string[];
				plate: string[];
				container: string[];
			}
		>
	>({});

	// Theme colors
	const backgroundColor = useThemeColor({}, "background");
	const textColor = useThemeColor({}, "text");
	const iconColor = useThemeColor({}, "icon");
	const separatorColor = useThemeColor({}, "separator");
	const headerColor = useThemeColor({}, "header");
	const accentColor = useThemeColor({}, "primary");
	const secondaryColor = useThemeColor({}, "secondary");

	// Navigation for date
	const goToPreviousDay = () => {
		const newDate = new Date(currentDate);
		newDate.setDate(currentDate.getDate() - 1);
		setCurrentDate(newDate);
	};

	const goToNextDay = () => {
		const newDate = new Date(currentDate);
		newDate.setDate(currentDate.getDate() + 1);
		setCurrentDate(newDate);
	};

	const formatDate = () => {
		const months = [
			"Jan",
			"Feb",
			"Mar",
			"Apr",
			"May",
			"Jun",
			"Jul",
			"Aug",
			"Sep",
			"Oct",
			"Nov",
			"Dec",
		];
		const month = months[currentDate.getMonth()];
		const day = currentDate.getDate();
		return `${month} ${day}`;
	};

	const handleLogout = () => {
		console.log("Logging out...");
		router.replace("/");
	};

	const toggleMealExpansion = (meal: MealCategory) => {
		setExpandedMeals((prev) => ({
			...prev,
			[meal]: !prev[meal],
		}));
	};

	const openFoodItemSelection = (mealCategory: MealCategory) => {
		setSelectedMeal(mealCategory);
		setShowFoodModal(true);
		setSearchTerm("");
	};

	const addFoodToMeal = (foodItem: FoodItem) => {
		if (!selectedMeal) return;

		const newItem = {
			...foodItem,
			id: `${foodItem.id}-${Date.now()}`, // Make unique ID
			mealCategory: selectedMeal,
		};

		setTrackedFoodItems((prev) => [...prev, newItem]);
		setShowFoodModal(false);

		// Initialize image data structure for this item
		setImageData((prev) => ({
			...prev,
			[newItem.id]: { buffet: [], plate: [], container: [] },
		}));
	};

	const openFoodItemDetails = (item: FoodItem) => {
		setActiveFoodItem(item);
		// Reset measurement data
		setWeight("");
		setVolume("");
		setDensity(null);
	};

	const closeFoodItemDetails = () => {
		setActiveFoodItem(null);
	};

	const openCamera = (mode: CameraMode) => {
		if (!activeFoodItem) {
			Alert.alert("No Food Item Selected", "Please select a food item first.");
			return;
		}
		setCameraMode(mode);
		setShowCamera(true);
	};

	const handlePictureTaken = (uri: string | null) => {
		setShowCamera(false);
		if (uri && cameraMode && activeFoodItem) {
			const itemId = activeFoodItem.id;
			setImageData((prev) => {
				const updatedItem = { ...prev[itemId] };
				updatedItem[cameraMode] = [...updatedItem[cameraMode], uri];
				return { ...prev, [itemId]: updatedItem };
			});
		}
		setCameraMode(null);
	};

	const calculateDensity = () => {
		const w = parseFloat(weight);
		const v = parseFloat(volume);
		if (!isNaN(w) && !isNaN(v) && v > 0) {
			setDensity(w / v);
			Alert.alert(
				"Density Calculated",
				`Density: ${(w / v).toFixed(2)} g/mL (or g/cm³)`,
			);
		} else if (!isNaN(w) && volume === "") {
			Alert.alert("Weight Recorded", `Weight: ${w.toFixed(2)} g`);
			setDensity(null);
		} else {
			Alert.alert(
				"Invalid Input",
				"Please enter valid numeric weight and optional positive volume.",
			);
			setDensity(null);
		}
	};

	const renderImageThumbnails = (images: string[], title: string) => (
		<View style={styles.thumbnailContainer}>
			<ThemedText style={styles.subHeader}>{title}</ThemedText>
			{images.length === 0 ? (
				<ThemedText style={styles.noImagesText}>No images taken yet</ThemedText>
			) : (
				<ScrollView
					horizontal
					showsHorizontalScrollIndicator={false}
					style={styles.thumbnailScroll}
				>
					{images.map((uri, index) => (
						<Image key={index} source={{ uri }} style={styles.thumbnail} />
					))}
				</ScrollView>
			)}
		</View>
	);

	// Food selection modal
	const renderFoodSelectionModal = () => {
		const filteredItems = availableFoodItems.filter((item) =>
			item.name.toLowerCase().includes(searchTerm.toLowerCase()),
		);

		return (
			<Modal
				visible={showFoodModal}
				animationType="slide"
				transparent={false}
				onRequestClose={() => setShowFoodModal(false)}
			>
				<ThemedView style={styles.modalContainer}>
					<View style={styles.modalHeader}>
						<TouchableOpacity onPress={() => setShowFoodModal(false)}>
							<MaterialIcons name="close" size={24} color={iconColor} />
						</TouchableOpacity>
						<ThemedText style={styles.modalTitle}>
							Select Food Item for {selectedMeal}
						</ThemedText>
						<View style={{ width: 24 }} />
					</View>

					<ThemedTextInput
						style={styles.searchInput}
						placeholder="Search food items..."
						value={searchTerm}
						onChangeText={setSearchTerm}
					/>

					<ScrollView style={styles.foodItemList}>
						{filteredItems.map((item) => (
							<TouchableOpacity
								key={item.id}
								style={styles.foodItemSelection}
								onPress={() => addFoodToMeal(item)}
							>
								<View style={styles.foodIcon}>
									<MaterialIcons
										name="restaurant"
										size={24}
										color={iconColor}
									/>
								</View>
								<ThemedText style={styles.foodItemName}>{item.name}</ThemedText>
								<MaterialIcons name="add" size={24} color={accentColor} />
							</TouchableOpacity>
						))}
						{filteredItems.length === 0 && (
							<ThemedText style={styles.noResultsText}>
								No food items found
							</ThemedText>
						)}
					</ScrollView>
				</ThemedView>
			</Modal>
		);
	};

	// If camera is active, show only the camera component
	if (showCamera) {
		return <CameraComponent onPictureTaken={handlePictureTaken} />;
	}

	// Food Item Detail View
	if (activeFoodItem) {
		const itemImages = imageData[activeFoodItem.id] || {
			buffet: [],
			plate: [],
			container: [],
		};

		return (
			<ThemedView style={styles.container}>
				<View style={styles.detailHeader}>
					<TouchableOpacity onPress={closeFoodItemDetails}>
						<MaterialIcons name="arrow-back" size={24} color={iconColor} />
					</TouchableOpacity>
					<ThemedText style={styles.detailTitle}>
						{activeFoodItem.name}
					</ThemedText>
					<View style={{ width: 24 }} />
				</View>

				<ScrollView style={styles.detailContent}>
					{/* Weight & Density Section */}
					<View style={styles.section}>
						<ThemedText style={styles.subHeader}>Weight & Density</ThemedText>
						<ThemedTextInput
							style={styles.input}
							placeholder="Weight (grams)"
							value={weight}
							onChangeText={setWeight}
							keyboardType="numeric"
						/>
						<ThemedTextInput
							style={styles.input}
							placeholder="Volume (mL or cm³, optional)"
							value={volume}
							onChangeText={setVolume}
							keyboardType="numeric"
						/>
						<Button
							title="Record Weight / Calculate Density"
							onPress={calculateDensity}
						/>
						{density !== null && (
							<ThemedText style={styles.densityText}>
								Calculated Density: {density.toFixed(2)} g/mL
							</ThemedText>
						)}
					</View>

					{/* Image Capture Section */}
					<View style={styles.section}>
						<ThemedText style={styles.subHeader}>Capture Images</ThemedText>
						<View style={styles.buttonRow}>
							<Button
								title="Take Buffet Photo"
								onPress={() => openCamera("buffet")}
							/>
							<Button
								title="Take Plate Photo"
								onPress={() => openCamera("plate")}
							/>
							<Button
								title="Take Container Photo"
								onPress={() => openCamera("container")}
							/>
						</View>
					</View>

					{/* Image Thumbnails Display */}
					{renderImageThumbnails(itemImages.buffet, "Buffet Images")}
					{renderImageThumbnails(itemImages.plate, "Plate Images")}
					{renderImageThumbnails(itemImages.container, "Container Images")}
				</ScrollView>
			</ThemedView>
		);
	}

	return (
		<ThemedView style={styles.container}>
			{/* Date navigation header - Cronometer Style */}
			<View style={[styles.dateHeader, { backgroundColor: headerColor }]}>
				<TouchableOpacity onPress={goToPreviousDay} style={styles.dateArrow}>
					<MaterialIcons name="chevron-left" size={28} color={textColor} />
				</TouchableOpacity>

				<ThemedText style={styles.dateTitle}>{formatDate()}</ThemedText>

				<TouchableOpacity onPress={goToNextDay} style={styles.dateArrow}>
					<MaterialIcons name="chevron-right" size={28} color={textColor} />
				</TouchableOpacity>

				<TouchableOpacity onPress={handleLogout} style={styles.logoutButton}>
					<MaterialIcons name="logout" size={24} color={textColor} />
				</TouchableOpacity>
			</View>

			<ScrollView style={styles.mealList}>
				{/* Breakfast Section */}
				<View style={styles.mealSection}>
					<TouchableOpacity
						style={styles.mealHeader}
						onPress={() => toggleMealExpansion("Breakfast")}
					>
						<ThemedText style={styles.mealTitle}>Breakfast</ThemedText>
						<MaterialIcons
							name={expandedMeals.Breakfast ? "expand-less" : "expand-more"}
							size={24}
							color={iconColor}
						/>
					</TouchableOpacity>

					{expandedMeals.Breakfast && (
						<View style={styles.mealContent}>
							{/* List food items for breakfast */}
							{trackedFoodItems
								.filter((item) => item.mealCategory === "Breakfast")
								.map((item) => (
									<TouchableOpacity
										key={item.id}
										style={styles.foodItem}
										onPress={() => openFoodItemDetails(item)}
									>
										<View style={styles.foodItemContent}>
											<View style={styles.foodIcon}>
												<MaterialIcons
													name="restaurant"
													size={24}
													color={iconColor}
												/>
											</View>
											<ThemedText style={styles.foodItemName}>
												{item.name}
											</ThemedText>
											<MaterialIcons
												name="chevron-right"
												size={24}
												color={iconColor}
											/>
										</View>
									</TouchableOpacity>
								))}

							{/* Add food button */}
							<TouchableOpacity
								style={styles.addFoodButton}
								onPress={() => openFoodItemSelection("Breakfast")}
							>
								<MaterialIcons name="add" size={24} color={accentColor} />
								<ThemedText style={styles.addFoodText}>Add Food</ThemedText>
							</TouchableOpacity>
						</View>
					)}
				</View>

				{/* Lunch Section */}
				<View style={styles.mealSection}>
					<TouchableOpacity
						style={styles.mealHeader}
						onPress={() => toggleMealExpansion("Lunch")}
					>
						<ThemedText style={styles.mealTitle}>Lunch</ThemedText>
						<MaterialIcons
							name={expandedMeals.Lunch ? "expand-less" : "expand-more"}
							size={24}
							color={iconColor}
						/>
					</TouchableOpacity>

					{expandedMeals.Lunch && (
						<View style={styles.mealContent}>
							{/* List food items for lunch */}
							{trackedFoodItems
								.filter((item) => item.mealCategory === "Lunch")
								.map((item) => (
									<TouchableOpacity
										key={item.id}
										style={styles.foodItem}
										onPress={() => openFoodItemDetails(item)}
									>
										<View style={styles.foodItemContent}>
											<View style={styles.foodIcon}>
												<MaterialIcons
													name="restaurant"
													size={24}
													color={iconColor}
												/>
											</View>
											<ThemedText style={styles.foodItemName}>
												{item.name}
											</ThemedText>
											<MaterialIcons
												name="chevron-right"
												size={24}
												color={iconColor}
											/>
										</View>
									</TouchableOpacity>
								))}

							{/* Add food button */}
							<TouchableOpacity
								style={styles.addFoodButton}
								onPress={() => openFoodItemSelection("Lunch")}
							>
								<MaterialIcons name="add" size={24} color={accentColor} />
								<ThemedText style={styles.addFoodText}>Add Food</ThemedText>
							</TouchableOpacity>
						</View>
					)}
				</View>

				{/* Dinner Section */}
				<View style={styles.mealSection}>
					<TouchableOpacity
						style={styles.mealHeader}
						onPress={() => toggleMealExpansion("Dinner")}
					>
						<ThemedText style={styles.mealTitle}>Dinner</ThemedText>
						<MaterialIcons
							name={expandedMeals.Dinner ? "expand-less" : "expand-more"}
							size={24}
							color={iconColor}
						/>
					</TouchableOpacity>

					{expandedMeals.Dinner && (
						<View style={styles.mealContent}>
							{/* List food items for dinner */}
							{trackedFoodItems
								.filter((item) => item.mealCategory === "Dinner")
								.map((item) => (
									<TouchableOpacity
										key={item.id}
										style={styles.foodItem}
										onPress={() => openFoodItemDetails(item)}
									>
										<View style={styles.foodItemContent}>
											<View style={styles.foodIcon}>
												<MaterialIcons
													name="restaurant"
													size={24}
													color={iconColor}
												/>
											</View>
											<ThemedText style={styles.foodItemName}>
												{item.name}
											</ThemedText>
											<MaterialIcons
												name="chevron-right"
												size={24}
												color={iconColor}
											/>
										</View>
									</TouchableOpacity>
								))}

							{/* Add food button */}
							<TouchableOpacity
								style={styles.addFoodButton}
								onPress={() => openFoodItemSelection("Dinner")}
							>
								<MaterialIcons name="add" size={24} color={accentColor} />
								<ThemedText style={styles.addFoodText}>Add Food</ThemedText>
							</TouchableOpacity>
						</View>
					)}
				</View>

				{/* Snacks Section */}
				<View style={styles.mealSection}>
					<TouchableOpacity
						style={styles.mealHeader}
						onPress={() => toggleMealExpansion("Snacks")}
					>
						<ThemedText style={styles.mealTitle}>Snacks</ThemedText>
						<MaterialIcons
							name={expandedMeals.Snacks ? "expand-less" : "expand-more"}
							size={24}
							color={iconColor}
						/>
					</TouchableOpacity>

					{expandedMeals.Snacks && (
						<View style={styles.mealContent}>
							{/* List food items for snacks */}
							{trackedFoodItems
								.filter((item) => item.mealCategory === "Snacks")
								.map((item) => (
									<TouchableOpacity
										key={item.id}
										style={styles.foodItem}
										onPress={() => openFoodItemDetails(item)}
									>
										<View style={styles.foodItemContent}>
											<View style={styles.foodIcon}>
												<MaterialIcons
													name="restaurant"
													size={24}
													color={iconColor}
												/>
											</View>
											<ThemedText style={styles.foodItemName}>
												{item.name}
											</ThemedText>
											<MaterialIcons
												name="chevron-right"
												size={24}
												color={iconColor}
											/>
										</View>
									</TouchableOpacity>
								))}

							{/* Add food button */}
							<TouchableOpacity
								style={styles.addFoodButton}
								onPress={() => openFoodItemSelection("Snacks")}
							>
								<MaterialIcons name="add" size={24} color={accentColor} />
								<ThemedText style={styles.addFoodText}>Add Food</ThemedText>
							</TouchableOpacity>
						</View>
					)}
				</View>
			</ScrollView>

			{/* Food Selection Modal */}
			{renderFoodSelectionModal()}
		</ThemedView>
	);
}

const styles = StyleSheet.create({
	container: {
		flex: 1,
	},
	// Date Header - Cronometer Style
	dateHeader: {
		flexDirection: "row",
		alignItems: "center",
		paddingHorizontal: 15,
		paddingTop: 50,
		paddingBottom: 15,
	},
	dateArrow: {
		padding: 10,
	},
	dateTitle: {
		fontSize: 24,
		fontWeight: "bold",
		flex: 1,
		textAlign: "center",
	},
	logoutButton: {
		padding: 10,
	},
	// Meal Sections
	mealList: {
		flex: 1,
	},
	mealSection: {
		marginBottom: 1, // Minimal gap between sections
		borderBottomWidth: 1,
		borderBottomColor: "#eee",
	},
	mealHeader: {
		flexDirection: "row",
		justifyContent: "space-between",
		alignItems: "center",
		paddingHorizontal: 15,
		paddingVertical: 15,
		backgroundColor: "rgba(0,0,0,0.05)",
	},
	mealTitle: {
		fontSize: 18,
		fontWeight: "600",
	},
	mealContent: {
		paddingBottom: 10,
	},
	// Food Items
	foodItem: {
		borderBottomWidth: 1,
		borderBottomColor: "#eee",
	},
	foodItemContent: {
		flexDirection: "row",
		alignItems: "center",
		paddingHorizontal: 15,
		paddingVertical: 15,
	},
	foodIcon: {
		marginRight: 10,
	},
	foodItemName: {
		flex: 1,
		fontSize: 16,
	},
	// Add Food Button
	addFoodButton: {
		flexDirection: "row",
		alignItems: "center",
		paddingHorizontal: 15,
		paddingVertical: 15,
	},
	addFoodText: {
		marginLeft: 10,
		fontSize: 16,
		color: "#2196F3", // Blue color for add action
	},
	// Modal for food selection
	modalContainer: {
		flex: 1,
		paddingTop: 40,
	},
	modalHeader: {
		flexDirection: "row",
		alignItems: "center",
		paddingHorizontal: 15,
		paddingVertical: 15,
		borderBottomWidth: 1,
		borderBottomColor: "#eee",
	},
	modalTitle: {
		flex: 1,
		fontSize: 18,
		fontWeight: "600",
		textAlign: "center",
	},
	searchInput: {
		margin: 15,
		paddingHorizontal: 10,
		paddingVertical: 8,
		borderWidth: 1,
		borderColor: "#ccc",
		borderRadius: 5,
	},
	foodItemList: {
		flex: 1,
	},
	foodItemSelection: {
		flexDirection: "row",
		alignItems: "center",
		paddingHorizontal: 15,
		paddingVertical: 15,
		borderBottomWidth: 1,
		borderBottomColor: "#eee",
	},
	noResultsText: {
		textAlign: "center",
		padding: 20,
		fontStyle: "italic",
		color: "#888",
	},
	// Detail View
	detailHeader: {
		flexDirection: "row",
		alignItems: "center",
		paddingHorizontal: 15,
		paddingTop: 50,
		paddingBottom: 15,
		borderBottomWidth: 1,
		borderBottomColor: "#ccc",
	},
	detailTitle: {
		flex: 1,
		fontSize: 20,
		fontWeight: "600",
		textAlign: "center",
	},
	detailContent: {
		flex: 1,
	},
	// Sections
	section: {
		paddingHorizontal: 15,
		paddingVertical: 15,
		borderBottomWidth: 1,
		borderBottomColor: "#eee",
	},
	subHeader: {
		fontSize: 18,
		fontWeight: "600",
		marginBottom: 15,
	},
	input: {
		marginBottom: 15,
	},
	densityText: {
		marginTop: 10,
		fontSize: 16,
		fontStyle: "italic",
		textAlign: "center",
	},
	buttonRow: {
		flexDirection: "row",
		justifyContent: "space-around",
		marginBottom: 15,
		flexWrap: "wrap",
		gap: 10,
	},
	// Thumbnails
	thumbnailContainer: {
		paddingHorizontal: 15,
		paddingVertical: 15,
		borderBottomWidth: 1,
		borderBottomColor: "#eee",
	},
	thumbnailScroll: {
		marginTop: 5,
	},
	thumbnail: {
		width: 100,
		height: 100,
		borderRadius: 8,
		marginRight: 10,
		borderWidth: 1,
		borderColor: "#ccc",
	},
	noImagesText: {
		fontSize: 14,
		color: "#888",
		fontStyle: "italic",
	},
});

// ./app/_layout.tsx
import {
	DarkTheme,
	DefaultTheme,
	ThemeProvider as NavigationThemeProvider,
} from "@react-navigation/native";
import { useFonts } from "expo-font";
import { Stack } from "expo-router";
import * as SplashScreen from "expo-splash-screen";
import { useEffect } from "react";
import "react-native-reanimated";

import { AppThemeProvider, useAppTheme } from "@/context/ThemeContext";
import { ThemeToggleButton } from "@/components/ThemeToggleButton";
import { Colors } from "@/constants/Colors";

// Prevent splash screen auto-hide
SplashScreen.preventAutoHideAsync();

// Inner component that uses the theme context
function RootNavigation() {
	const { theme } = useAppTheme();
	const headerBackgroundColor =
		theme === "light"
			? Colors.light.headerBackground
			: Colors.dark.headerBackground;
	const headerTintColor =
		theme === "light" ? Colors.light.text : Colors.dark.text;

	return (
		<NavigationThemeProvider
			value={theme === "dark" ? DarkTheme : DefaultTheme}
		>
			<Stack
				screenOptions={{
					// Apply header options globally
					headerStyle: {
						backgroundColor: headerBackgroundColor,
					},
					headerTintColor: headerTintColor,
					headerRight: () => <ThemeToggleButton />,
				}}
			>
				<Stack.Screen
					name="index"
					options={{ title: "Home", headerShown: true }}
				/>
				<Stack.Screen
					name="login"
					options={{ title: "Login", headerShown: true }}
				/>
                <Stack.Screen
                    name="signup"
                    options={{ title: "Sign Up", headerShown: true }}
                />
				<Stack.Screen
					name="adminDashboard"
					options={{ title: "Admin Dashboard" }}
				/>
				<Stack.Screen name="userDashboard" options={{ title: "User Screen" }} />
				<Stack.Screen
					name="staffDashboard"
					options={{ title: "Image Taker" }}
				/>
				<Stack.Screen
					name="nutritionDashboard"
					options={{ title: "Nutrition Dashboard" }}
				/>

				{/* +not-found screen */}
				<Stack.Screen name="+not-found" />
			</Stack>
		</NavigationThemeProvider>
	);
}

export default function RootLayout() {
	// Font loading logic remains the same
	const [loaded, error] = useFonts({
		SpaceMono: require("../assets/fonts/SpaceMono-Regular.ttf"),
	});

	useEffect(() => {
		if (error) throw error;
	}, [error]);

	useEffect(() => {
		if (loaded) {
			SplashScreen.hideAsync();
		}
	}, [loaded]);

	if (!loaded) {
		return null;
	}

	// Wrap the entire navigation structure with your theme provider
	return (
		<AppThemeProvider>
			<RootNavigation />
		</AppThemeProvider>
	);
}

// ./app/+not-found.tsx
import { Link, Stack } from "expo-router";
import { StyleSheet } from "react-native";

import { ThemedText } from "@/components/ThemedText";
import { ThemedView } from "@/components/ThemedView";

export default function NotFoundScreen() {
	return (
		<>
			<Stack.Screen options={{ title: "Oops!" }} />
			<ThemedView style={styles.container}>
				<ThemedText type="title">This screen doesn't exist.</ThemedText>
				<Link href="/" style={styles.link}>
					<ThemedText type="link">Go to home screen!</ThemedText>
				</Link>
			</ThemedView>
		</>
	);
}

const styles = StyleSheet.create({
	container: {
		flex: 1,
		alignItems: "center",
		justifyContent: "center",
		padding: 20,
	},
	link: {
		marginTop: 15,
		paddingVertical: 15,
	},
});

// ./app/nutritionDashboard.tsx
import React, { useState } from "react";
import {
	View,
	FlatList,
	StyleSheet,
	Modal,
	Button,
	Alert,
	TouchableOpacity,
} from "react-native";
import { ThemedView } from "@/components/ThemedView";
import { ThemedText } from "@/components/ThemedText";
import { ThemedTextInput } from "@/components/ThemedTextInput"; // Assuming you create/have this
import { MaterialIcons } from "@expo/vector-icons"; // For icons
import { useThemeColor } from "@/hooks/useThemeColor";
import { router } from "expo-router"; // For logout if needed

// Define the structure for food item data including nutrition
interface FoodItem {
	id: string;
	name: string;
	calories: number;
	protein: number; // grams
	carbs: number; // grams
	fat: number; // grams
}

// Fake data for now
const initialFoodData: FoodItem[] = [
	{ id: "1", name: "Apple", calories: 95, protein: 0.5, carbs: 25, fat: 0.3 },
	{
		id: "2",
		name: "Chicken Breast (100g)",
		calories: 165,
		protein: 31,
		carbs: 0,
		fat: 3.6,
	},
	{
		id: "3",
		name: "Brown Rice (cooked, 1 cup)",
		calories: 215,
		protein: 5,
		carbs: 45,
		fat: 1.8,
	},
	{
		id: "4",
		name: "Broccoli (1 cup)",
		calories: 55,
		protein: 3.7,
		carbs: 11,
		fat: 0.6,
	},
];

export default function NutritionistDashboardScreen() {
	const [foodItems, setFoodItems] = useState<FoodItem[]>(initialFoodData);
	const [modalVisible, setModalVisible] = useState(false);
	const [selectedItem, setSelectedItem] = useState<FoodItem | null>(null);
	// State for the input fields in the modal
	const [editName, setEditName] = useState("");
	const [editCalories, setEditCalories] = useState("");
	const [editProtein, setEditProtein] = useState("");
	const [editCarbs, setEditCarbs] = useState("");
	const [editFat, setEditFat] = useState("");

	const backgroundColor = useThemeColor({}, "background");
	const textColor = useThemeColor({}, "text");
	const iconColor = useThemeColor({}, "icon");
	const separatorColor = useThemeColor({}, "separator");
	const inputBackgroundColor = useThemeColor({}, "inputBackground"); // Add this color to your theme setup

	const handleEditPress = (item: FoodItem) => {
		setSelectedItem(item);
		setEditName(item.name); // Pre-fill modal fields
		setEditCalories(item.calories.toString());
		setEditProtein(item.protein.toString());
		setEditCarbs(item.carbs.toString());
		setEditFat(item.fat.toString());
		setModalVisible(true);
	};

	const handleSave = () => {
		if (!selectedItem) return;

		// Basic validation (can be improved)
		const calories = parseFloat(editCalories);
		const protein = parseFloat(editProtein);
		const carbs = parseFloat(editCarbs);
		const fat = parseFloat(editFat);

		if (isNaN(calories) || isNaN(protein) || isNaN(carbs) || isNaN(fat)) {
			Alert.alert("Invalid Input", "Nutritional values must be numbers.");
			return;
		}
		if (!editName.trim()) {
			Alert.alert("Invalid Input", "Food item name cannot be empty.");
			return;
		}

		setFoodItems((prevItems) =>
			prevItems.map((item) =>
				item.id === selectedItem.id
					? { ...item, name: editName, calories, protein, carbs, fat }
					: item,
			),
		);
		setModalVisible(false);
		setSelectedItem(null); // Clear selection
	};

	const handleLogout = () => {
		// Add actual logout logic here (clear tokens/state) if implemented
		console.log("Logging out...");
		router.replace("/"); // Navigate to login screen
	};

	const renderItem = ({ item }: { item: FoodItem }) => (
		<View style={[styles.itemContainer, { borderBottomColor: separatorColor }]}>
			<View style={styles.itemTextContainer}>
				<ThemedText style={styles.itemName}>{item.name}</ThemedText>
				<ThemedText style={styles.itemDetail}>
					Cal: {item.calories} | P: {item.protein}g | C: {item.carbs}g | F:{" "}
					{item.fat}g
				</ThemedText>
			</View>
			<TouchableOpacity
				onPress={() => handleEditPress(item)}
				style={styles.iconButton}
			>
				<MaterialIcons name="edit" size={24} color={iconColor} />
			</TouchableOpacity>
		</View>
	);

	return (
		<ThemedView style={styles.container}>
			<View style={styles.header}>
				<ThemedText style={styles.title}>Nutritionist Dashboard</ThemedText>
				{/* Optional Logout Button */}
				<TouchableOpacity onPress={handleLogout} style={styles.logoutButton}>
					<MaterialIcons name="logout" size={24} color={iconColor} />
				</TouchableOpacity>
			</View>

			<FlatList
				data={foodItems}
				renderItem={renderItem}
				keyExtractor={(item) => item.id}
				style={styles.list}
			/>

			{/* Edit Modal */}
			<Modal
				animationType="slide"
				transparent={true}
				visible={modalVisible}
				onRequestClose={() => {
					setModalVisible(!modalVisible);
					setSelectedItem(null);
				}}
			>
				<View style={styles.modalCenteredView}>
					<ThemedView style={styles.modalView}>
						<ThemedText style={styles.modalTitle}>
							Edit Nutritional Info
						</ThemedText>

						<ThemedText style={styles.label}>Name</ThemedText>
						<ThemedTextInput
							style={styles.input} // Use ThemedTextInput
							placeholder="Food Item Name"
							value={editName}
							onChangeText={setEditName}
							// placeholderTextColor={useThemeColor({}, 'secondaryText')} // Optional: finer theme control
						/>

						<ThemedText style={styles.label}>Calories</ThemedText>
						<ThemedTextInput
							style={styles.input}
							placeholder="e.g., 150"
							value={editCalories}
							onChangeText={setEditCalories}
							keyboardType="numeric"
						/>

						<ThemedText style={styles.label}>Protein (g)</ThemedText>
						<ThemedTextInput
							style={styles.input}
							placeholder="e.g., 25"
							value={editProtein}
							onChangeText={setEditProtein}
							keyboardType="numeric"
						/>

						<ThemedText style={styles.label}>Carbs (g)</ThemedText>
						<ThemedTextInput
							style={styles.input}
							placeholder="e.g., 10"
							value={editCarbs}
							onChangeText={setEditCarbs}
							keyboardType="numeric"
						/>

						<ThemedText style={styles.label}>Fat (g)</ThemedText>
						<ThemedTextInput
							style={styles.input}
							placeholder="e.g., 5"
							value={editFat}
							onChangeText={setEditFat}
							keyboardType="numeric"
						/>

						<View style={styles.modalButtonContainer}>
							<Button
								title="Cancel"
								onPress={() => {
									setModalVisible(false);
									setSelectedItem(null);
								}}
								color="#ff6347"
							/>
							<Button title="Save" onPress={handleSave} />
						</View>
					</ThemedView>
				</View>
			</Modal>
		</ThemedView>
	);
}

const styles = StyleSheet.create({
	container: {
		flex: 1,
	},
	header: {
		flexDirection: "row",
		justifyContent: "space-between",
		alignItems: "center",
		paddingHorizontal: 15,
		paddingTop: 50, // Adjust for status bar height if needed (use SafeAreaView or react-native-safe-area-context)
		paddingBottom: 10,
		borderBottomWidth: 1,
		borderBottomColor: "#ccc", // Use theme color later
	},
	title: {
		fontSize: 24,
		fontWeight: "bold",
	},
	logoutButton: {
		padding: 5,
	},
	list: {
		flex: 1,
	},
	itemContainer: {
		flexDirection: "row",
		justifyContent: "space-between",
		alignItems: "center",
		paddingVertical: 15,
		paddingHorizontal: 15,
		borderBottomWidth: 1,
		// borderBottomColor set dynamically
	},
	itemTextContainer: {
		flex: 1, // Allows text to take available space
		marginRight: 10, // Space before the button
	},
	itemName: {
		fontSize: 18,
		fontWeight: "500",
	},
	itemDetail: {
		fontSize: 14,
		opacity: 0.8,
		marginTop: 4,
	},
	iconButton: {
		padding: 8, // Increase touch area slightly
	},
	// Modal Styles (similar to adminDashboard)
	modalCenteredView: {
		flex: 1,
		justifyContent: "center",
		alignItems: "center",
		backgroundColor: "rgba(0, 0, 0, 0.5)", // Semi-transparent background
	},
	modalView: {
		margin: 20,
		borderRadius: 20,
		padding: 35,
		alignItems: "stretch", // Make items stretch
		shadowColor: "#000",
		shadowOffset: {
			width: 0,
			height: 2,
		},
		shadowOpacity: 0.25,
		shadowRadius: 4,
		elevation: 5,
		width: "90%", // Control modal width
	},
	modalTitle: {
		marginBottom: 20,
		textAlign: "center",
		fontSize: 20,
		fontWeight: "bold",
	},
	label: {
		fontSize: 16,
		marginBottom: 5,
		// fontWeight: '500', // Optional
	},
	input: {
		// Using ThemedTextInput now, style it as needed or rely on ThemedTextInput's internal styles
		// Example styles if ThemedTextInput doesn't have them:
		// height: 40,
		// borderWidth: 1,
		// padding: 10,
		marginBottom: 15,
		// borderRadius: 5,
		// Specify themed border/background in ThemedTextInput or here
	},
	modalButtonContainer: {
		flexDirection: "row",
		justifyContent: "space-around", // Space out buttons
		marginTop: 20,
	},
});

// ./app/adminDashboard.tsx
import React, { useState, useEffect } from "react";
import {
	StyleSheet,
	View,
	FlatList,
	Alert,
	TouchableOpacity,
	Modal,
	TextInput,
	ScrollView, // Use ScrollView for Modal content if it gets long
	Platform,
	KeyboardAvoidingView, // Handle keyboard overlap
} from "react-native";
import { Stack, useRouter } from "expo-router";
import { ThemedView } from "@/components/ThemedView";
import { ThemedText } from "@/components/ThemedText";
import { useThemeColor } from "@/hooks/useThemeColor";
import { MaterialIcons } from "@expo/vector-icons";

// Define the structure for a food item
interface FoodItem {
	id: string;
	name: string;
	description?: string; // Optional description
	// Add other relevant fields later e.g., imageUrl, calories etc.
}

// Generate some fake initial data
const generateInitialData = (count: number): FoodItem[] => {
	const items: FoodItem[] = [];
	const sampleNames = [
		"Dal Makhani",
		"Paneer Butter Masala",
		"Chicken Curry",
		"Vegetable Biryani",
		"Roti",
		"Rice",
		"Gulab Jamun",
		"Salad",
		"Samosa",
		"Idli",
		"Dosa",
		"Upma",
		"Chole Bhature",
		"Aloo Gobi",
		"Mixed Veg",
	];
	for (let i = 0; i < count; i++) {
		const name =
			sampleNames[i % sampleNames.length] +
			(count > sampleNames.length
				? ` ${Math.floor(i / sampleNames.length) + 1}`
				: "");
		items.push({
			id: `item-${Date.now()}-${i}`, // Simple unique ID
			name: name,
			description: `Description for ${name}`,
		});
	}
	return items;
};

export default function AdminScreen() {
	const router = useRouter();
	const [foodItems, setFoodItems] = useState<FoodItem[]>([]);
	const [modalVisible, setModalVisible] = useState(false);
	const [currentItem, setCurrentItem] = useState<FoodItem | null>(null); // For editing
	const [itemName, setItemName] = useState("");
	const [itemDescription, setItemDescription] = useState("");

	const cardBackground = useThemeColor({}, "headerBackground");
	const textColor = useThemeColor({}, "text");
	const iconColor = useThemeColor({}, "icon");
	const primaryColor = useThemeColor({}, "primary");
	const buttonTextColor = useThemeColor({}, "background");
	const borderColor = useThemeColor({}, "border"); // For input borders

	// Load initial data on mount
	useEffect(() => {
		setFoodItems(generateInitialData(12)); // Generate 10-15 items as requested for fake data
	}, []);

	// --- CRUD Handlers ---

	const handleAddNew = () => {
		setCurrentItem(null); // Ensure we are adding, not editing
		setItemName("");
		setItemDescription("");
		setModalVisible(true);
	};

	const handleEdit = (item: FoodItem) => {
		setCurrentItem(item);
		setItemName(item.name);
		setItemDescription(item.description || "");
		setModalVisible(true);
	};

	const handleDelete = (id: string) => {
		Alert.alert(
			"Confirm Delete",
			"Are you sure you want to delete this item?",
			[
				{ text: "Cancel", style: "cancel" },
				{
					text: "Delete",
					style: "destructive",
					onPress: () => {
						setFoodItems((prevItems) =>
							prevItems.filter((item) => item.id !== id),
						);
					},
				},
			],
		);
	};

	const handleSave = () => {
		if (!itemName.trim()) {
			Alert.alert("Error", "Item name cannot be empty.");
			return;
		}

		if (currentItem) {
			// Editing existing item
			setFoodItems((prevItems) =>
				prevItems.map((item) =>
					item.id === currentItem.id
						? {
								...item,
								name: itemName.trim(),
								description: itemDescription.trim(),
							}
						: item,
				),
			);
		} else {
			// Adding new item
			const newItem: FoodItem = {
				id: `item-${Date.now()}`, // Simple unique ID
				name: itemName.trim(),
				description: itemDescription.trim(),
			};
			setFoodItems((prevItems) => [newItem, ...prevItems]); // Add to the top
		}

		setModalVisible(false);
		// Clear form state
		setCurrentItem(null);
		setItemName("");
		setItemDescription("");
	};

	// Function to handle logout (similar to UserScreen)
	const handleLogout = () => {
		router.replace("/"); // Navigate back to login
	};

	// --- Render Item ---
	const renderItem = ({ item }: { item: FoodItem }) => (
		<View style={[styles.itemContainer, { backgroundColor: cardBackground }]}>
			<View style={styles.itemTextContainer}>
				<ThemedText style={styles.itemName}>{item.name}</ThemedText>
				{item.description && (
					<ThemedText style={styles.itemDescription} numberOfLines={2}>
						{item.description}
					</ThemedText>
				)}
			</View>
			<View style={styles.itemActions}>
				<TouchableOpacity
					onPress={() => handleEdit(item)}
					style={styles.actionButton}
				>
					<MaterialIcons name="edit" size={24} color={iconColor} />
				</TouchableOpacity>
				<TouchableOpacity
					onPress={() => handleDelete(item.id)}
					style={styles.actionButton}
				>
					<MaterialIcons name="delete" size={24} color={"red"} />{" "}
					{/* Use red for delete */}
				</TouchableOpacity>
			</View>
		</View>
	);

	return (
		<ThemedView style={styles.container}>
			<Stack.Screen
				options={{
					title: "Admin Dashboard",
					headerRight: () => (
						<TouchableOpacity
							onPress={handleLogout}
							style={styles.headerButton}
						>
							<MaterialIcons name="logout" size={24} color={iconColor} />
						</TouchableOpacity>
					),
				}}
			/>

			<FlatList
				data={foodItems}
				renderItem={renderItem}
				keyExtractor={(item) => item.id}
				style={styles.list}
				ListHeaderComponent={
					// Button to add new item at the top
					<TouchableOpacity
						style={[styles.addButton, { backgroundColor: primaryColor }]}
						onPress={handleAddNew}
					>
						<MaterialIcons name="add" size={24} color={buttonTextColor} />
						<ThemedText
							style={[styles.addButtonText, { color: buttonTextColor }]}
						>
							Add New Food Item
						</ThemedText>
					</TouchableOpacity>
				}
				ListEmptyComponent={
					<ThemedText style={styles.emptyListText}>
						No food items found. Add some!
					</ThemedText>
				}
				contentContainerStyle={styles.listContentContainer}
			/>

			{/* Add/Edit Modal */}
			<Modal
				animationType="slide"
				transparent={true}
				visible={modalVisible}
				onRequestClose={() => {
					setModalVisible(!modalVisible);
					// Optionally reset state if modal is closed via back button etc.
					setCurrentItem(null);
					setItemName("");
					setItemDescription("");
				}}
			>
				{/* Use KeyboardAvoidingView for better input handling */}
				<KeyboardAvoidingView
					behavior={Platform.OS === "ios" ? "padding" : "height"}
					style={styles.modalOverlay}
				>
					<View style={[styles.modalView, { backgroundColor: cardBackground }]}>
						<ScrollView>
							<ThemedText style={styles.modalTitle}>
								{currentItem ? "Edit Food Item" : "Add New Food Item"}
							</ThemedText>

							<ThemedText style={styles.inputLabel}>Name *</ThemedText>
							<TextInput
								style={[
									styles.input,
									{ color: textColor, borderColor: borderColor },
								]}
								placeholder="Enter item name"
								placeholderTextColor={iconColor} // Use iconColor for placeholder contrast
								value={itemName}
								onChangeText={setItemName}
							/>

							<ThemedText style={styles.inputLabel}>Description</ThemedText>
							<TextInput
								style={[
									styles.input,
									styles.textArea,
									{ color: textColor, borderColor: borderColor },
								]}
								placeholder="Enter item description (optional)"
								placeholderTextColor={iconColor}
								value={itemDescription}
								onChangeText={setItemDescription}
								multiline={true}
								numberOfLines={3}
							/>

							<View style={styles.modalActions}>
								<TouchableOpacity
									style={[styles.modalButton, styles.cancelButton]}
									onPress={() => setModalVisible(false)}
								>
									<ThemedText style={styles.modalButtonText}>Cancel</ThemedText>
								</TouchableOpacity>
								<TouchableOpacity
									style={[
										styles.modalButton,
										styles.saveButton,
										{ backgroundColor: primaryColor },
									]}
									onPress={handleSave}
								>
									<ThemedText
										style={[styles.modalButtonText, { color: buttonTextColor }]}
									>
										Save
									</ThemedText>
								</TouchableOpacity>
							</View>
						</ScrollView>
					</View>
				</KeyboardAvoidingView>
			</Modal>
		</ThemedView>
	);
}

// Styles
const styles = StyleSheet.create({
	container: {
		flex: 1,
	},
	headerButton: {
		marginRight: 15,
		padding: 5,
	},
	list: {
		flex: 1,
	},
	listContentContainer: {
		padding: 16,
	},
	addButton: {
		flexDirection: "row",
		alignItems: "center",
		justifyContent: "center",
		paddingVertical: 12,
		borderRadius: 8,
		marginBottom: 16, // Space below add button
	},
	addButtonText: {
		marginLeft: 8,
		fontSize: 16,
		fontWeight: "bold",
	},
	emptyListText: {
		textAlign: "center",
		marginTop: 50,
		fontSize: 16,
		color: "#888", // Use a subtle color
	},
	itemContainer: {
		flexDirection: "row",
		justifyContent: "space-between",
		alignItems: "center",
		padding: 15,
		marginBottom: 10,
		borderRadius: 8,
		shadowColor: "#000",
		shadowOffset: { width: 0, height: 1 },
		shadowOpacity: 0.1,
		shadowRadius: 2,
		elevation: 2,
	},
	itemTextContainer: {
		flex: 1, // Allow text to take available space
		marginRight: 10, // Space between text and actions
	},
	itemName: {
		fontSize: 16,
		fontWeight: "bold",
	},
	itemDescription: {
		fontSize: 13,
		opacity: 0.8,
		marginTop: 4,
	},
	itemActions: {
		flexDirection: "row",
	},
	actionButton: {
		marginLeft: 15, // Space between edit/delete buttons
		padding: 5, // Increase touch area
	},
	// Modal Styles
	modalOverlay: {
		flex: 1,
		justifyContent: "center",
		alignItems: "center",
		backgroundColor: "rgba(0, 0, 0, 0.5)", // Semi-transparent background
	},
	modalView: {
		margin: 20,
		borderRadius: 12,
		padding: 25, // Increased padding
		width: "90%", // Modal width
		maxHeight: "80%", // Prevent modal from being too tall
		shadowColor: "#000",
		shadowOffset: { width: 0, height: 2 },
		shadowOpacity: 0.25,
		shadowRadius: 4,
		elevation: 5,
	},
	modalTitle: {
		marginBottom: 20, // Increased spacing
		textAlign: "center",
		fontSize: 18,
		fontWeight: "bold",
	},
	inputLabel: {
		fontSize: 14,
		marginBottom: 5,
		marginLeft: 2, // Align with input border
		opacity: 0.9,
	},
	input: {
		height: 45, // Increased height
		borderWidth: 1,
		borderRadius: 8, // More rounded corners
		paddingHorizontal: 12, // Increased padding
		marginBottom: 15, // Increased spacing
		fontSize: 15,
	},
	textArea: {
		height: 80, // Height for description
		textAlignVertical: "top", // Align text to top for multiline
		paddingTop: 10, // Padding top for multiline
	},
	modalActions: {
		flexDirection: "row",
		justifyContent: "flex-end", // Align buttons to the right
		marginTop: 20,
	},
	modalButton: {
		borderRadius: 8,
		paddingVertical: 10,
		paddingHorizontal: 20,
		marginLeft: 10,
		minWidth: 80, // Ensure minimum button width
		alignItems: "center", // Center text
	},
	cancelButton: {
		backgroundColor: "#ccc", // A standard cancel color
	},
	saveButton: {
		// backgroundColor set by primaryColor
	},
	modalButtonText: {
		fontWeight: "bold",
		fontSize: 15,
	},
});

// ./app/login.tsx
import React, { useState } from "react";
import { View, TextInput, Button, StyleSheet, Alert } from "react-native";
import { useRouter } from "expo-router";
import { ThemedText } from "@/components/ThemedText";
import { ThemedView } from "@/components/ThemedView";
import { useThemeColor } from "@/hooks/useThemeColor";

export default function LoginScreen() {
	const [username, setUsername] = useState("");
	const [password, setPassword] = useState("");
	const router = useRouter();

	// Get theme colors
	const textColor = useThemeColor({}, "text");
	const backgroundColor = useThemeColor({}, "background");
	const borderColor = useThemeColor({}, "icon");
	const placeholderColor = useThemeColor({}, "icon");

	const handleLogin = () => {
		// Basic client-side check (replace with real auth later)
		if (username === "admin" && password === "password") {
			// Use a placeholder password
			router.replace("/adminDashboard");
		} else if (username === "user" && password === "password") {
			router.replace("/userDashboard");
		} else if (username === "mess Staff" && password === "password") {
			router.replace("/staffDashboard");
		} else if (username === "nutrition" && password === "password") {
			router.replace("/nutritionDashboard");
		} else {
			Alert.alert("Login Failed", "Invalid username or password");
		}
	};

	return (
		<ThemedView style={styles.container}>
			<ThemedText type="title">Login</ThemedText>
			<TextInput
				style={[
					styles.input,
					{
						color: textColor,
						backgroundColor: backgroundColor,
						borderColor: borderColor,
					},
				]}
				placeholder="Username"
				value={username}
				onChangeText={setUsername}
				placeholderTextColor={placeholderColor}
			/>
			<TextInput
				style={[
					styles.input,
					{
						color: textColor,
						backgroundColor: backgroundColor,
						borderColor: borderColor,
					},
				]}
				placeholder="Password"
				value={password}
				onChangeText={setPassword}
				secureTextEntry
				placeholderTextColor={placeholderColor}
			/>
			<Button
				title="Login"
				onPress={handleLogin}
				color={useThemeColor({}, "primary")}
			/>
		</ThemedView>
	);
}

const styles = StyleSheet.create({
	container: {
		flex: 1,
		alignItems: "center",
		justifyContent: "center",
		padding: 20,
	},
	input: {
		width: "100%",
		marginVertical: 10,
		padding: 15,
		borderWidth: 1,
		borderRadius: 5,
	},
});

// ./app/userDashboard.tsx
import { Platform } from "react-native";

// Import both the native and web dashboard components
// Adjust the import paths based on where you save the files
import UserDashboardNative from "./userDashNative"; // Assuming you renamed the original
import UserDashboardWeb from "./userDashWeb"; // The web component created earlier

export default function UserDashboard() {
	// Check the platform
	if (Platform.OS === "web") {
		// If the platform is web, render the web-specific dashboard
		return <UserDashboardWeb />;
	} else {
		// Otherwise (iOS, Android), render the native dashboard
		return <UserDashboardNative />;
	}
}

// No styles needed here usually, as the styling is within the specific components.

// ./app/userDashWeb.tsx
import React, { useState, useEffect, useRef, useCallback } from 'react';
// import axios from 'axios'; // Or use fetch

interface CameraDevice {
  id: string;
  label: string;
}

interface NutritionResult {
  // Define the structure of the data you expect from your backend
  foodItem: string;
  calories: number;
  protein: number;
  // ... other nutritional info
  confidenceScore: number;
  rating: number; // Star rating
}

const UserWebDashboard: React.FC = () => {
  const [devices, setDevices] = useState<CameraDevice[]>([]);
  const [selectedDeviceId, setSelectedDeviceId] = useState<string | null>(null);
  const [stream, setStream] = useState<MediaStream | null>(null);
  const [capturedImage, setCapturedImage] = useState<string | null>(null); // Store as base64 data URL or blob URL
  const [results, setResults] = useState<NutritionResult | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [permissionGranted, setPermissionGranted] = useState<boolean | null>(null); // null = unknown, true = granted, false = denied/unavailable
  const [errorMessage, setErrorMessage] = useState<string | null>(null);

  const videoRef = useRef<HTMLVideoElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null); // For capturing frame

  // --- Permission Handling ---
  const checkAndRequestPermissions = useCallback(async () => {
    setErrorMessage(null);
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        setErrorMessage('Camera access is not supported by this browser.');
        setPermissionGranted(false);
        return;
    }
    try {
        // Check permission status first
        const permissionStatus = await navigator.permissions.query({ name: 'camera' as PermissionName }); // Cast needed for older TS versions
        if (permissionStatus.state === 'granted') {
            setPermissionGranted(true);
            loadDevices(); // Load devices if permission already granted
        } else if (permissionStatus.state === 'prompt') {
            setPermissionGranted(null); // Still need to ask
             // Optional: show a message explaining why you need camera before requesting
            requestCameraAccess(); // Or trigger this via a user action like a button press
        } else { // denied
            setErrorMessage('Camera permission was denied. Please enable it in your browser settings.');
            setPermissionGranted(false);
        }

        permissionStatus.onchange = () => {
             if(permissionStatus.state === 'granted') {
                setPermissionGranted(true);
                loadDevices();
             } else {
                setPermissionGranted(false);
                setErrorMessage('Camera permission status changed.');
                stopStream(); // Stop stream if permission revoked
             }
        }

    } catch (error) {
        console.error("Error checking/requesting permissions:", error);
        setErrorMessage('Error checking camera permissions.');
        setPermissionGranted(false);
    }
  }, []);

  const requestCameraAccess = async () => {
     try {
        // Requesting access here will trigger the prompt if state was 'prompt'
        await navigator.mediaDevices.getUserMedia({ video: true });
        setPermissionGranted(true);
        loadDevices(); // Load devices after getting permission
     } catch(error: any) {
        console.error("Error getting user media:", error);
         if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
           setErrorMessage('You denied camera access. Please enable it in browser settings.');
         } else {
           setErrorMessage(`Could not access camera: ${error.message}`);
         }
        setPermissionGranted(false);
     }
  }


  // --- Device Handling ---
  const loadDevices = useCallback(async () => {
    try {
        await navigator.mediaDevices.getUserMedia({ video: true }); // Ensure permission is active before enumerating
        const availableDevices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = availableDevices
            .filter(device => device.kind === 'videoinput')
            .map(device => ({ id: device.deviceId, label: device.label || `Camera ${devices.length + 1}` }));
        setDevices(videoDevices);
        if (videoDevices.length > 0 && !selectedDeviceId) {
            setSelectedDeviceId(videoDevices[0].id); // Select the first camera by default
        }
    } catch (error) {
        console.error("Error loading devices:", error);
        setErrorMessage('Could not load camera devices.');
        setPermissionGranted(false); // Likely permission issue
    }
  }, [selectedDeviceId]); // dependency added


  // --- Stream Handling ---
  const startStream = useCallback(async () => {
    if (stream) { // Stop previous stream if changing device
        stopStream();
    }
    if (selectedDeviceId && permissionGranted) {
        try {
            const mediaStream = await navigator.mediaDevices.getUserMedia({
                video: { deviceId: { exact: selectedDeviceId } }
            });
            setStream(mediaStream);
            if (videoRef.current) {
                videoRef.current.srcObject = mediaStream;
            }
        } catch (error) {
            console.error("Error starting stream:", error);
            setErrorMessage('Could not start camera stream.');
             setPermissionGranted(false); // Might be a permission issue again
        }
    }
  }, [selectedDeviceId, permissionGranted]); // Added stream to dependencies

  const stopStream = () => {
    if (stream) {
        stream.getTracks().forEach(track => track.stop());
        setStream(null);
         if (videoRef.current) {
             videoRef.current.srcObject = null;
         }
    }
  };

  // --- Effects ---
  useEffect(() => {
    checkAndRequestPermissions(); // Check permissions on component mount
    // Cleanup function to stop stream when component unmounts
    return () => {
        stopStream();
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []); // Run only once on mount


  useEffect(() => {
    if (permissionGranted && selectedDeviceId) {
      startStream(); // Start stream when permission is granted and a device is selected
    } else {
        stopStream(); // Stop if permission lost or no device
    }
    // Include startStream in dependencies if needed, ensure useCallback covers its own deps
  }, [permissionGranted, selectedDeviceId, startStream]);

  // --- Capture & Upload ---
  const captureImage = () => {
    setResults(null); // Clear previous results
    setErrorMessage(null);
    if (videoRef.current && canvasRef.current) {
        const video = videoRef.current;
        const canvas = canvasRef.current;
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const context = canvas.getContext('2d');
        if (context) {
            context.drawImage(video, 0, 0, canvas.width, canvas.height);
            // Get image data (e.g., as base64 data URL)
            const imageDataUrl = canvas.toDataURL('image/jpeg'); // Or image/png
            setCapturedImage(imageDataUrl);
            // Send to backend
            uploadImage(imageDataUrl);
        }
    }
  };

  const uploadImage = async (imageDataUrl: string) => {
    setIsLoading(true);
    try {
        // Assuming your backend expects a POST request with JSON payload
        const response = await fetch('/api/analyze-food', { // Replace with your actual backend endpoint
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                // Add Authorization header if needed:
                // 'Authorization': `Bearer ${your_jwt_token}`
            },
            body: JSON.stringify({ image: imageDataUrl }), // Send base64 string
        });

        if (!response.ok) {
            throw new Error(`Server responded with status: ${response.status}`);
        }

        const data: NutritionResult = await response.json();
        setResults(data);

    } catch (error: any) {
        console.error("Error uploading image:", error);
        setErrorMessage(`Failed to get analysis: ${error.message}`);
        setResults(null);
    } finally {
        setIsLoading(false);
    }
  };

  // --- Rendering ---
  return (
    <div>
      <h2>User Web Dashboard</h2>

      {errorMessage && <p style={{ color: 'red' }}>Error: {errorMessage}</p>}

      {!permissionGranted && permissionGranted !== null && (
         <button onClick={requestCameraAccess}>Grant Camera Permission</button>
      )}


      {permissionGranted && (
        <div>
           {/* Camera Selection Dropdown */}
           <label htmlFor="camera-select">Select Camera:</label>
           <select
             id="camera-select"
             value={selectedDeviceId ?? ''}
             onChange={(e) => setSelectedDeviceId(e.target.value)}
             disabled={devices.length === 0}
           >
             {devices.map(device => (
               <option key={device.id} value={device.id}>
                 {device.label}
               </option>
             ))}
           </select>

           {/* Video Preview */}
           <div style={{ position: 'relative', width: '640px', height: '480px', border:'1px solid black', margin: '10px 0' }}>
                <video
                    ref={videoRef}
                    autoPlay
                    playsInline // Important for mobile browsers
                    style={{ width: '100%', height: '100%' }}
                    muted // Often required for autoplay
                />
                {/* Hidden canvas for capturing */}
                <canvas ref={canvasRef} style={{ display: 'none' }} />
           </div>


           {/* Capture Button */}
           <button onClick={captureImage} disabled={!stream || isLoading}>
             {isLoading ? 'Analyzing...' : 'Take Picture & Analyze'}
           </button>

           {/* Display Captured Image (Optional) */}
           {/* {capturedImage && <img src={capturedImage} alt="Captured" width="320" />} */}

           {/* Display Results */}
           {isLoading && <p>Loading results...</p>}
           {results && (
             <div>
               <h3>Analysis Results</h3>
               <p>Food Item: {results.foodItem}</p>
               <p>Calories: {results.calories}</p>
               <p>Protein: {results.protein}</p>
               {/* ... other results */}
               <p>Confidence: {results.confidenceScore}</p>
               <p>Rating: {'⭐'.repeat(results.rating)}</p> {/* Example star rating */}
             </div>
           )}
        </div>
      )}
    </div>
  );
};

export default UserWebDashboard;

// ./app/userDashNative.tsx
import React, { useState } from "react";
import {
	StyleSheet,
	View,
	Image,
	TouchableOpacity,
	ScrollView,
	Button,
	Platform,
	Alert, // Added Alert
} from "react-native";
import { Stack, useRouter } from "expo-router";
import { ThemedView } from "@/components/ThemedView";
import { ThemedText } from "@/components/ThemedText";
import { CameraComponent } from "@/components/CameraComponent";
import { useThemeColor } from "@/hooks/useThemeColor";
import { MaterialIcons } from "@expo/vector-icons";
import { StarRating } from "@/components/StarRating";

export default function UserScreen() {
	const [photoUri, setPhotoUri] = useState<string | null>(null);
	const [showCamera, setShowCamera] = useState(false);
	const [nutritionalInfo, setNutritionalInfo] = useState<string | null>(null);
	// NEW: State for model's confidence score
	const [modelConfidence, setModelConfidence] = useState<number | null>(null);
	// REPURPOSED: State for the USER'S rating input
	const [userRating, setUserRating] = useState<number | null>(null);
	// State to track if results are being loaded
	const [isLoading, setIsLoading] = useState(false);

	const router = useRouter();

	const buttonColor = useThemeColor({}, "primary");
	const buttonTextColor = useThemeColor({}, "background");
	const cardBackground = useThemeColor({}, "headerBackground");
	const textColor = useThemeColor({}, "text");
	const iconColor = useThemeColor({}, "icon");

	const handlePictureTaken = (uri: string) => {
		setPhotoUri(uri);
		setShowCamera(false);
		setIsLoading(true); // Start loading indicator
		setNutritionalInfo(null); // Clear previous results
		setModelConfidence(null);
		setUserRating(null); // Reset user rating for new picture

		console.log("Photo URI:", uri);
		// --- Backend Interaction Placeholder ---
		// Simulate backend processing delay
		setTimeout(() => {
			// Assume backend returns nutritional info and model confidence
			setNutritionalInfo("Calories: 410, Protein: 18g, Carbs: 55g, Fat: 12g");
			setModelConfidence(0.85); // Example confidence score (e.g., 85%)
			setIsLoading(false); // Stop loading indicator
		}, 2000); // Simulate 2 second network delay
		// --- End Backend Interaction Placeholder ---
	};

	// Handler for the user setting their rating
	const handleSetUserRating = (rating: number) => {
		setUserRating(rating);
		// Optional: Send the user rating to the backend here
		console.log("User rated:", rating);
		Alert.alert(
			"Rating Submitted",
			`You rated ${rating} stars. Thank you for your feedback!`,
		); // Give feedback
	};

	const handleOpenCamera = () => {
		// Clear all previous results and states when opening camera
		setPhotoUri(null);
		setNutritionalInfo(null);
		setModelConfidence(null);
		setUserRating(null);
		setIsLoading(false);
		setShowCamera(true);
	};

	const handleCloseCamera = () => {
		setShowCamera(false);
	};

	const handleLogout = () => {
		router.replace("/");
	};

	if (showCamera) {
		return (
			<CameraComponent
				onPictureTaken={handlePictureTaken}
				onClose={handleCloseCamera}
			/>
		);
	}

	return (
		<ThemedView style={styles.container}>
			<Stack.Screen
				options={{
					title: "User Dashboard",
					headerRight: () => (
						<TouchableOpacity
							onPress={handleLogout}
							style={styles.headerButton}
						>
							<MaterialIcons name="logout" size={24} color={iconColor} />
						</TouchableOpacity>
					),
				}}
			/>

			<ScrollView
				style={styles.content}
				contentContainerStyle={styles.contentContainer}
				keyboardShouldPersistTaps="handled" // Allow taps outside inputs to dismiss keyboard if needed later
			>
				{/* Card for Camera Action */}
				<View style={[styles.card, { backgroundColor: cardBackground }]}>
					<ThemedText type="subtitle" style={styles.cardTitle}>
						Analyze Meal
					</ThemedText>
					{/* ... (Image display or placeholder remains the same) ... */}
					{
						photoUri && !isLoading ? ( // Show image if not loading
							<View style={styles.photoContainer}>
								<ThemedText style={styles.infoLabel}>
									Captured Image:
								</ThemedText>
								<Image source={{ uri: photoUri }} style={styles.photo} />
							</View>
						) : !photoUri && !isLoading ? ( // Show placeholder if no photo and not loading
							<View style={styles.placeholder}>
								<MaterialIcons name="camera-alt" size={50} color={iconColor} />
								<ThemedText style={styles.placeholderText}>
									Press the button below to take a picture of your meal.
								</ThemedText>
							</View>
						) : null /* Or show a specific placeholder during loading if desired */
					}

					<TouchableOpacity
						style={[styles.button, { backgroundColor: buttonColor }]}
						onPress={handleOpenCamera}
						disabled={isLoading} // Disable button while loading
					>
						<MaterialIcons
							name="camera"
							size={20}
							color={buttonTextColor}
							style={{ marginRight: 8 }}
						/>
						<ThemedText style={[styles.buttonText, { color: buttonTextColor }]}>
							{photoUri ? "Analyze Another Meal" : "Take Picture"}
						</ThemedText>
					</TouchableOpacity>
				</View>

				{/* Card for Results (shown after photo is taken OR during loading) */}
				{(photoUri || isLoading) && (
					<View style={[styles.card, { backgroundColor: cardBackground }]}>
						<ThemedText type="subtitle" style={styles.cardTitle}>
							Analysis Results
						</ThemedText>

						{isLoading ? (
							<ThemedText style={styles.infoText}>
								Analyzing image...
							</ThemedText>
						) : nutritionalInfo ? (
							<>
								{/* Display Model Confidence */}
								{modelConfidence !== null && (
									<>
										<ThemedText style={styles.infoLabel}>
											Model Confidence:
										</ThemedText>
										<ThemedText style={styles.infoText}>
											{(modelConfidence * 100).toFixed(0)}%{" "}
											{/* Display as percentage */}
										</ThemedText>
									</>
								)}

								{/* Display Nutritional Values */}
								<ThemedText style={[styles.infoLabel, { marginTop: 15 }]}>
									Nutritional Values:
								</ThemedText>
								<ThemedText style={styles.infoText}>
									{nutritionalInfo}
								</ThemedText>

								{/* User Rating Section */}
								<ThemedText style={[styles.infoLabel, { marginTop: 15 }]}>
									Rate this Analysis:
								</ThemedText>
								<StarRating
									rating={userRating} // Pass the user's current rating state
									onRate={handleSetUserRating} // Pass the handler function
									size={32} // Make stars larger for interaction
								/>
							</>
						) : (
							// Handle case where loading finished but no info (e.g., error)
							<ThemedText style={styles.infoText}>
								Could not analyze image.
							</ThemedText>
						)}
					</View>
				)}
			</ScrollView>
		</ThemedView>
	);
}

// Styles (add or adjust as needed)
const styles = StyleSheet.create({
	// ... (Keep existing styles: container, headerButton, content, contentContainer, card, cardTitle) ...
	container: {
		flex: 1,
	},
	headerButton: {
		marginRight: 15,
		padding: 5,
	},
	content: {
		flex: 1,
	},
	contentContainer: {
		padding: 16,
		paddingBottom: 32, // Ensure space at the bottom
	},
	card: {
		borderRadius: 12,
		padding: 16,
		marginBottom: 20,
		shadowColor: "#000",
		shadowOffset: { width: 0, height: 1 },
		shadowOpacity: 0.1,
		shadowRadius: 3,
		elevation: 3,
	},
	cardTitle: {
		marginBottom: 15,
		textAlign: "center",
	},
	photoContainer: {
		alignItems: "center",
		marginVertical: 16,
		width: "100%",
	},
	photo: {
		width: "90%",
		aspectRatio: 1,
		borderRadius: 8,
		marginTop: 8,
		resizeMode: "cover",
	},
	placeholder: {
		height: 180,
		borderRadius: 8,
		justifyContent: "center",
		alignItems: "center",
		alignSelf: "center",
		marginVertical: 20,
		width: "90%",
		padding: 15,
	},
	placeholderText: {
		marginTop: 10,
		fontStyle: "italic",
		textAlign: "center",
		opacity: 0.8,
	},
	button: {
		flexDirection: "row",
		paddingVertical: 12,
		paddingHorizontal: 20,
		borderRadius: 8,
		alignItems: "center",
		justifyContent: "center",
		marginTop: 16,
		minWidth: 180,
		alignSelf: "center",
	},
	buttonText: {
		fontSize: 16,
		fontWeight: "bold",
	},
	infoLabel: {
		fontWeight: "bold",
		marginTop: 10,
		fontSize: 16,
	},
	infoText: {
		fontSize: 15,
		marginTop: 5,
		lineHeight: 22,
	},
});

// ./hooks/useThemeColor.ts
/**
 * Learn more about light and dark modes:
 * https://docs.expo.dev/guides/color-schemes/
 */

import { Colors } from '@/constants/Colors';
import { useColorScheme } from '@/hooks/useColorScheme';

export function useThemeColor(
  props: { light?: string; dark?: string },
  colorName: keyof typeof Colors.light & keyof typeof Colors.dark
) {
  const theme = useColorScheme() ?? 'light';
  const colorFromProps = props[theme];

  if (colorFromProps) {
    return colorFromProps;
  } else {
    return Colors[theme][colorName];
  }
}

// ./hooks/useColorScheme.web.ts
import { useEffect, useState } from 'react';
import { useColorScheme as useRNColorScheme } from 'react-native';

/**
 * To support static rendering, this value needs to be re-calculated on the client side for web
 */
export function useColorScheme() {
  const [hasHydrated, setHasHydrated] = useState(false);

  useEffect(() => {
    setHasHydrated(true);
  }, []);

  const colorScheme = useRNColorScheme();

  if (hasHydrated) {
    return colorScheme;
  }

  return 'light';
}

// ./hooks/useColorScheme.ts
import { useAppTheme } from "@/context/ThemeContext"; // Import the hook

/**
 * Hook that provides the current color scheme preference (light or dark).
 * Prioritizes the user's choice from ThemeContext.
 */
export function useColorScheme(): "light" | "dark" {
	const { theme } = useAppTheme(); // Get the theme from context
	return theme;
}

// You might not need the .web.ts variant anymore, or it should also use the context.

// ./.expo/types/router.d.ts
/* eslint-disable */
import * as Router from 'expo-router';

export * from 'expo-router';

declare module 'expo-router' {
  export namespace ExpoRouter {
    export interface __routes<T extends string | object = string> {
      hrefInputParams: { pathname: Router.RelativePathString, params?: Router.UnknownInputParams } | { pathname: Router.ExternalPathString, params?: Router.UnknownInputParams } | { pathname: `/adminDashboard`; params?: Router.UnknownInputParams; } | { pathname: `/`; params?: Router.UnknownInputParams; } | { pathname: `/login`; params?: Router.UnknownInputParams; } | { pathname: `/nutritionDashboard`; params?: Router.UnknownInputParams; } | { pathname: `/signup`; params?: Router.UnknownInputParams; } | { pathname: `/staffDashboard`; params?: Router.UnknownInputParams; } | { pathname: `/userDashNative`; params?: Router.UnknownInputParams; } | { pathname: `/userDashWeb`; params?: Router.UnknownInputParams; } | { pathname: `/userDashboard`; params?: Router.UnknownInputParams; } | { pathname: `/_sitemap`; params?: Router.UnknownInputParams; } | { pathname: `/+not-found`, params: Router.UnknownInputParams & {  } };
      hrefOutputParams: { pathname: Router.RelativePathString, params?: Router.UnknownOutputParams } | { pathname: Router.ExternalPathString, params?: Router.UnknownOutputParams } | { pathname: `/adminDashboard`; params?: Router.UnknownOutputParams; } | { pathname: `/`; params?: Router.UnknownOutputParams; } | { pathname: `/login`; params?: Router.UnknownOutputParams; } | { pathname: `/nutritionDashboard`; params?: Router.UnknownOutputParams; } | { pathname: `/signup`; params?: Router.UnknownOutputParams; } | { pathname: `/staffDashboard`; params?: Router.UnknownOutputParams; } | { pathname: `/userDashNative`; params?: Router.UnknownOutputParams; } | { pathname: `/userDashWeb`; params?: Router.UnknownOutputParams; } | { pathname: `/userDashboard`; params?: Router.UnknownOutputParams; } | { pathname: `/_sitemap`; params?: Router.UnknownOutputParams; } | { pathname: `/+not-found`, params: Router.UnknownOutputParams & {  } };
      href: Router.RelativePathString | Router.ExternalPathString | `/adminDashboard${`?${string}` | `#${string}` | ''}` | `/${`?${string}` | `#${string}` | ''}` | `/login${`?${string}` | `#${string}` | ''}` | `/nutritionDashboard${`?${string}` | `#${string}` | ''}` | `/signup${`?${string}` | `#${string}` | ''}` | `/staffDashboard${`?${string}` | `#${string}` | ''}` | `/userDashNative${`?${string}` | `#${string}` | ''}` | `/userDashWeb${`?${string}` | `#${string}` | ''}` | `/userDashboard${`?${string}` | `#${string}` | ''}` | `/_sitemap${`?${string}` | `#${string}` | ''}` | { pathname: Router.RelativePathString, params?: Router.UnknownInputParams } | { pathname: Router.ExternalPathString, params?: Router.UnknownInputParams } | { pathname: `/adminDashboard`; params?: Router.UnknownInputParams; } | { pathname: `/`; params?: Router.UnknownInputParams; } | { pathname: `/login`; params?: Router.UnknownInputParams; } | { pathname: `/nutritionDashboard`; params?: Router.UnknownInputParams; } | { pathname: `/signup`; params?: Router.UnknownInputParams; } | { pathname: `/staffDashboard`; params?: Router.UnknownInputParams; } | { pathname: `/userDashNative`; params?: Router.UnknownInputParams; } | { pathname: `/userDashWeb`; params?: Router.UnknownInputParams; } | { pathname: `/userDashboard`; params?: Router.UnknownInputParams; } | { pathname: `/_sitemap`; params?: Router.UnknownInputParams; } | `/+not-found` | { pathname: `/+not-found`, params: Router.UnknownInputParams & {  } };
    }
  }
}

// ./components/ThemeToggleButton.tsx
import React from "react";
import { TouchableOpacity, StyleSheet } from "react-native";
import { MaterialIcons } from "@expo/vector-icons";
import { useAppTheme } from "@/context/ThemeContext"; // Adjust import path if needed
import { useThemeColor } from "@/hooks/useThemeColor"; // Adjust import path if needed

export const ThemeToggleButton = () => {
	const { toggleTheme, theme } = useAppTheme();
	const iconColor = useThemeColor({}, "icon");
	const iconName = theme === "light" ? "dark-mode" : "light-mode";

	return (
		<TouchableOpacity
			onPress={toggleTheme}
			hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }} // Adds 10 points of slop on each side
			style={styles.button} // Keep your existing styles like marginRight
		>
			<MaterialIcons name={iconName} size={24} color={iconColor} />
		</TouchableOpacity>
	);
};

const styles = StyleSheet.create({
	button: {
		// marginRight: 15,
		// padding: -10,
	},
});

// ./components/ThemedTextInput.tsx
import React from "react";
import { TextInput, StyleSheet, type TextInputProps } from "react-native";
import { useThemeColor } from "@/hooks/useThemeColor"; // Ensure this path is correct

// Extend standard TextInputProps to accept all TextInput properties
// Add 'style' prop specifically for overriding/extending styles
export type ThemedTextInputProps = TextInputProps & {
	style?: object; // Allow passing custom styles
	lightColor?: string; // Optional overrides for light theme
	darkColor?: string; // Optional overrides for dark theme
};

export function ThemedTextInput({
	style,
	lightColor, // Not directly used for input background/border, but could be for text if needed
	darkColor, // Not directly used for input background/border, but could be for text if needed
	placeholderTextColor: customPlaceholderTextColor, // Allow overriding placeholder color specifically
	...rest // Pass all other TextInput props down
}: ThemedTextInputProps) {
	// Fetch theme-specific colors using your hook
	const color = useThemeColor({ light: lightColor, dark: darkColor }, "text");
	const backgroundColor = useThemeColor({}, "inputBackground"); // Use the inputBackground color defined in your theme
	const borderColor = useThemeColor({}, "inputBorder"); // Use the inputBorder color defined in your theme
	const placeholderTextColor =
		customPlaceholderTextColor ?? useThemeColor({}, "placeholderText"); // Use custom or theme's placeholder color

	return (
		<TextInput
			style={[
				styles.default, // Default styles first
				{
					color: color,
					backgroundColor: backgroundColor,
					borderColor: borderColor,
				},
				style, // Apply custom styles passed via props last (to override defaults)
			]}
			placeholderTextColor={placeholderTextColor} // Apply the determined placeholder color
			{...rest} // Spread the rest of the TextInput props
		/>
	);
}

const styles = StyleSheet.create({
	default: {
		height: 45, // Default height
		borderWidth: 1, // Default border
		borderRadius: 8, // Default corner rounding
		paddingHorizontal: 12, // Default horizontal padding
		fontSize: 16, // Default font size
		marginBottom: 15, // Default bottom margin (adjust as needed)
	},
});

// ./components/CameraComponent.tsx
import React, { useState, useRef, useEffect } from "react";
import {
	View,
	StyleSheet,
	TouchableOpacity,
	Text,
	Alert,
	Platform,
	Button,
} from "react-native";
import { CameraView, CameraType, useCameraPermissions } from "expo-camera";
import { MaterialIcons } from "@expo/vector-icons";
import { useThemeColor } from "@/hooks/useThemeColor";
import AsyncStorage from "@react-native-async-storage/async-storage";

type CameraComponentProps = {
	onPictureTaken: (uri: string) => void;
	onClose: () => void;
};

export function CameraComponent({
	onPictureTaken,
	onClose,
}: CameraComponentProps) {
	const [permission, requestPermission] = useCameraPermissions();
	const [facing, setFacing] = useState<CameraType>("back");
	const cameraRef = useRef<CameraView>(null); // Ref type updated to CameraView
	const iconColor = useThemeColor({}, "icon");
	const buttonBackgroundColor = useThemeColor({}, "primary");
	const buttonTextColor = useThemeColor({}, "background");

	useEffect(() => {
		const loadCameraType = async () => {
			const savedType = await AsyncStorage.getItem("cameraType");
			if (savedType === "front") {
				setFacing("front");
			} else {
				setFacing("back"); // Default to 'back'
			}
		};
		loadCameraType();
	}, []);

	if (!permission) {
		// Permissions are still loading
		return (
			<View style={styles.centered}>
				<Text>Requesting camera permissions...</Text>
			</View>
		);
	}

	if (!permission.granted) {
		return (
			<View style={[styles.container, styles.centered]}>
				<Stack.Screen options={{ headerShown: false }} />{" "}
				{/* Optionally hide header */}
				<Text style={styles.message}>
					We need your permission to show the camera.
				</Text>
				<Button onPress={requestPermission} title="Grant Permission" />
				<Button onPress={onClose} title="Cancel" />
			</View>
		);
	}

	const toggleCameraFacing = async () => {
		const newFacing = facing === "back" ? "front" : "back";
		setFacing(newFacing);
		await AsyncStorage.setItem("cameraType", newFacing);
	};

	const takePicture = async () => {
		if (cameraRef.current) {
			try {
				const photo = await cameraRef.current.takePictureAsync({
					quality: 0.7,
					base64: false,
				});
				if (photo?.uri) {
					onPictureTaken(photo.uri);
				} else {
					console.error("Failed to take picture: No URI returned");
					Alert.alert("Error", "Could not capture image.");
				}
			} catch (error) {
				console.error("Failed to take picture:", error);
				Alert.alert("Error", "Could not take picture.");
			}
		}
	};

	return (
		// Use CameraView instead of Camera
		<View style={styles.cameraContainer}>
			<CameraView
				ref={cameraRef}
				style={styles.camera}
				facing={facing} // Use facing prop
				// FlashMode might be handled differently or via props if needed
				// ratio="16:9" // Ratio might not be needed or set differently
			>
				{/* Keep controls within the CameraView or overlay them */}
				<View style={styles.cameraControls}>
					{/* Close Button */}
					<TouchableOpacity style={styles.controlButton} onPress={onClose}>
						<MaterialIcons name="close" size={30} color={iconColor} />
					</TouchableOpacity>
					{/* Flip Camera Button */}
					<TouchableOpacity
						style={styles.controlButton}
						onPress={toggleCameraFacing}
					>
						<MaterialIcons name="flip-camera-ios" size={30} color={iconColor} />
					</TouchableOpacity>
				</View>
			</CameraView>

			{/* Capture Button outside CameraView for positioning */}
			<TouchableOpacity
				style={[
					styles.captureButton,
					{ backgroundColor: buttonBackgroundColor },
				]}
				onPress={takePicture}
			>
				<MaterialIcons name="camera" size={40} color={buttonTextColor} />
			</TouchableOpacity>
		</View>
	);
}

// Styles remain largely the same, adjust as needed
const styles = StyleSheet.create({
	container: {
		// Added for permission screen
		flex: 1,
		justifyContent: "center",
		alignItems: "center",
		padding: 20,
	},
	centered: {
		// Added for centering content
		flex: 1,
		justifyContent: "center",
		alignItems: "center",
	},
	message: {
		// Added for permission screen
		textAlign: "center",
		marginBottom: 20,
		fontSize: 16,
	},
	cameraContainer: {
		flex: 1,
		width: "100%",
		backgroundColor: "#000",
		justifyContent: "flex-end",
		alignItems: "center",
	},
	camera: {
		// Adjust camera style: Make it cover most of the screen, leave space for controls maybe?
		position: "absolute",
		top: 0,
		left: 0,
		right: 0,
		bottom: 120, // Adjust space for the capture button area
	},
	cameraControls: {
		// Position controls at the top within the CameraView bounds or overlay
		flexDirection: "row",
		justifyContent: "space-between",
		backgroundColor: "transparent",
		width: "100%", // Ensure controls span width
		paddingHorizontal: 20,
		paddingTop: Platform.OS === "ios" ? 50 : 30, // Adjust for status bar/notch
		position: "absolute", // Position controls over the camera view
		top: 0,
		left: 0,
		right: 0,
		zIndex: 1, // Ensure controls are above the camera preview layer if needed
	},
	controlButton: {
		padding: 10,
		borderRadius: 50,
		backgroundColor: "rgba(0,0,0,0.4)",
	},
	captureButton: {
		width: 70,
		height: 70,
		borderRadius: 35,
		justifyContent: "center",
		alignItems: "center",
		marginBottom: 40, // Adjusted margin
		position: "absolute", // Position capture button absolutely at the bottom center
		bottom: 10,
		alignSelf: "center",
		zIndex: 2, // Ensure capture button is easily pressable
	},
});

// ./components/StarRating.tsx
import React from "react";
import { View, StyleSheet, TouchableOpacity } from "react-native"; // Added TouchableOpacity
import { MaterialIcons } from "@expo/vector-icons";
import { useThemeColor } from "@/hooks/useThemeColor";

interface StarRatingProps {
	rating: number | null; // Current rating value (can be null if unrated)
	maxStars?: number;
	size?: number;
	onRate?: (rating: number) => void; // Optional: Callback function when user rates
	disabled?: boolean; // Optional: Disable interaction
}

export function StarRating({
	rating,
	maxStars = 5,
	size = 28, // Slightly larger default for interaction
	onRate,
	disabled = false, // Default to interactive if onRate is provided
}: StarRatingProps) {
	const starColor = useThemeColor({}, "tint");
	const emptyStarColor = useThemeColor({}, "icon");
	// Determine if the component should be interactive
	const isInteractive = !!onRate && !disabled;

	const handlePress = (index: number) => {
		if (isInteractive && onRate) {
			onRate(index + 1); // Rating is 1-based index + 1
		}
	};

	const filledStars = rating ? Math.floor(rating) : 0;
	const displayRating = rating ?? 0; 
	const fullStars = Math.floor(displayRating);
	const halfStar = !isInteractive && displayRating % 1 >= 0.5; 
	const emptyStars = maxStars - fullStars - (halfStar ? 1 : 0);

	return (
		<View style={styles.container}>
			{[...Array(maxStars)].map((_, i) => {
				const starValue = i + 1;
				let iconName: "star" | "star-border" | "star-half" = "star-border";
				let color = emptyStarColor;

				if (rating !== null) {
					if (i < fullStars) {
						iconName = "star";
						color = starColor;
					} else if (i === fullStars && halfStar) {
						iconName = "star-half";
						color = starColor;
					}
				}

				return (
					<TouchableOpacity
						key={i}
						onPress={() => handlePress(i)}
						disabled={!isInteractive}
						style={styles.starTouchable} 
					>
						<MaterialIcons
							name={iconName}
							size={size}
							color={
								isInteractive && rating !== null && starValue <= rating
									? starColor
									: color
							} 
						/>
					</TouchableOpacity>
				);
			})}
		</View>
	);
}

const styles = StyleSheet.create({
	container: {
		flexDirection: "row",
		alignItems: "center",
		marginTop: 5,
	},
	starTouchable: {
		paddingHorizontal: 3, 
	},
});

// ./components/ThemedView.tsx
import { View, type ViewProps, StyleSheet } from "react-native";
import { useThemeColor } from "@/hooks/useThemeColor";

export type ThemedViewProps = ViewProps & {
	lightColor?: string;
	darkColor?: string;
};

export function ThemedView({
	style,
	lightColor,
	darkColor,
	...otherProps
}: ThemedViewProps) {
	const backgroundColor = useThemeColor(
		{ light: lightColor, dark: darkColor },
		"background",
	);

	return <View style={[{ backgroundColor }, style]} {...otherProps} />;
}

// ./components/ThemedText.tsx
import { Text, type TextProps, StyleSheet } from 'react-native';

import { useThemeColor } from '@/hooks/useThemeColor';

export type ThemedTextProps = TextProps & {
  lightColor?: string;
  darkColor?: string;
  type?: 'default' | 'title' | 'defaultSemiBold' | 'subtitle' | 'link';
};

export function ThemedText({
  style,
  lightColor,
  darkColor,
  type = 'default',
  ...rest
}: ThemedTextProps) {
  const color = useThemeColor({ light: lightColor, dark: darkColor }, 'text');

  return (
    <Text
      style={[
        { color },
        type === 'default' ? styles.default : undefined,
        type === 'title' ? styles.title : undefined,
        type === 'defaultSemiBold' ? styles.defaultSemiBold : undefined,
        type === 'subtitle' ? styles.subtitle : undefined,
        type === 'link' ? styles.link : undefined,
        style,
      ]}
      {...rest}
    />
  );
}

const styles = StyleSheet.create({
  default: {
    fontSize: 16,
    lineHeight: 24,
  },
  defaultSemiBold: {
    fontSize: 16,
    lineHeight: 24,
    fontWeight: '600',
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    lineHeight: 32,
  },
  subtitle: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  link: {
    lineHeight: 30,
    fontSize: 16,
    color: '#0a7ea4',
  },
});

// ./components/ExternalLink.tsx
import { Link } from 'expo-router';
import { openBrowserAsync } from 'expo-web-browser';
import { type ComponentProps } from 'react';
import { Platform } from 'react-native';

type Props = Omit<ComponentProps<typeof Link>, 'href'> & { href: string };

export function ExternalLink({ href, ...rest }: Props) {
  return (
    <Link
      target="_blank"
      {...rest}
      href={href}
      onPress={async (event) => {
        if (Platform.OS !== 'web') {
          // Prevent the default behavior of linking to the default browser on native.
          event.preventDefault();
          // Open the link in an in-app browser.
          await openBrowserAsync(href);
        }
      }}
    />
  );
}

// ./components/ui/TabBarBackground.tsx
// This is a shim for web and Android where the tab bar is generally opaque.
export default undefined;

export function useBottomTabOverflow() {
  return 0;
}

// ./components/ui/TabBarBackground.ios.tsx
import { useBottomTabBarHeight } from '@react-navigation/bottom-tabs';
import { BlurView } from 'expo-blur';
import { StyleSheet } from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

export default function BlurTabBarBackground() {
  return (
    <BlurView
      // System chrome material automatically adapts to the system's theme
      // and matches the native tab bar appearance on iOS.
      tint="systemChromeMaterial"
      intensity={100}
      style={StyleSheet.absoluteFill}
    />
  );
}

export function useBottomTabOverflow() {
  const tabHeight = useBottomTabBarHeight();
  const { bottom } = useSafeAreaInsets();
  return tabHeight - bottom;
}

